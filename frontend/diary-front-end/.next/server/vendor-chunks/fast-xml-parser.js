/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fast-xml-parser";
exports.ids = ["vendor-chunks/fast-xml-parser"];
exports.modules = {

/***/ "(ssr)/./node_modules/fast-xml-parser/src/fxp.js":
/*!*************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/fxp.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst validator = __webpack_require__(/*! ./validator */ \"(ssr)/./node_modules/fast-xml-parser/src/validator.js\");\nconst XMLParser = __webpack_require__(/*! ./xmlparser/XMLParser */ \"(ssr)/./node_modules/fast-xml-parser/src/xmlparser/XMLParser.js\");\nconst XMLBuilder = __webpack_require__(/*! ./xmlbuilder/json2xml */ \"(ssr)/./node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js\");\n\nmodule.exports = {\n  XMLParser: XMLParser,\n  XMLValidator: validator,\n  XMLBuilder: XMLBuilder\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy9meHAuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsa0JBQWtCLG1CQUFPLENBQUMsMEVBQWE7QUFDdkMsa0JBQWtCLG1CQUFPLENBQUMsOEZBQXVCO0FBQ2pELG1CQUFtQixtQkFBTyxDQUFDLDhGQUF1Qjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2RpYXJ5LWZyb250LWVuZC8uL25vZGVfbW9kdWxlcy9mYXN0LXhtbC1wYXJzZXIvc3JjL2Z4cC5qcz9kOGVjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdmFsaWRhdG9yID0gcmVxdWlyZSgnLi92YWxpZGF0b3InKTtcbmNvbnN0IFhNTFBhcnNlciA9IHJlcXVpcmUoJy4veG1scGFyc2VyL1hNTFBhcnNlcicpO1xuY29uc3QgWE1MQnVpbGRlciA9IHJlcXVpcmUoJy4veG1sYnVpbGRlci9qc29uMnhtbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgWE1MUGFyc2VyOiBYTUxQYXJzZXIsXG4gIFhNTFZhbGlkYXRvcjogdmFsaWRhdG9yLFxuICBYTUxCdWlsZGVyOiBYTUxCdWlsZGVyXG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-xml-parser/src/fxp.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/fast-xml-parser/src/util.js":
/*!**************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/util.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nconst nameStartChar = ':A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';\nconst nameChar = nameStartChar + '\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040';\nconst nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*'\nconst regexName = new RegExp('^' + nameRegexp + '$');\n\nconst getAllMatches = function(string, regex) {\n  const matches = [];\n  let match = regex.exec(string);\n  while (match) {\n    const allmatches = [];\n    allmatches.startIndex = regex.lastIndex - match[0].length;\n    const len = match.length;\n    for (let index = 0; index < len; index++) {\n      allmatches.push(match[index]);\n    }\n    matches.push(allmatches);\n    match = regex.exec(string);\n  }\n  return matches;\n};\n\nconst isName = function(string) {\n  const match = regexName.exec(string);\n  return !(match === null || typeof match === 'undefined');\n};\n\nexports.isExist = function(v) {\n  return typeof v !== 'undefined';\n};\n\nexports.isEmptyObject = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */\nexports.merge = function(target, a, arrayMode) {\n  if (a) {\n    const keys = Object.keys(a); // will return an array of own properties\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      if (arrayMode === 'strict') {\n        target[keys[i]] = [ a[keys[i]] ];\n      } else {\n        target[keys[i]] = a[keys[i]];\n      }\n    }\n  }\n};\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */\n\nexports.getValue = function(v) {\n  if (exports.isExist(v)) {\n    return v;\n  } else {\n    return '';\n  }\n};\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\n\nexports.isName = isName;\nexports.getAllMatches = getAllMatches;\nexports.nameRegexp = nameRegexp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QixvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDOztBQUVBLGNBQWM7QUFDZCxxQkFBcUI7QUFDckIsa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGlhcnktZnJvbnQtZW5kLy4vbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMvdXRpbC5qcz8yN2QwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgbmFtZVN0YXJ0Q2hhciA9ICc6QS1aYS16X1xcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEJztcbmNvbnN0IG5hbWVDaGFyID0gbmFtZVN0YXJ0Q2hhciArICdcXFxcLS5cXFxcZFxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwJztcbmNvbnN0IG5hbWVSZWdleHAgPSAnWycgKyBuYW1lU3RhcnRDaGFyICsgJ11bJyArIG5hbWVDaGFyICsgJ10qJ1xuY29uc3QgcmVnZXhOYW1lID0gbmV3IFJlZ0V4cCgnXicgKyBuYW1lUmVnZXhwICsgJyQnKTtcblxuY29uc3QgZ2V0QWxsTWF0Y2hlcyA9IGZ1bmN0aW9uKHN0cmluZywgcmVnZXgpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICBsZXQgbWF0Y2ggPSByZWdleC5leGVjKHN0cmluZyk7XG4gIHdoaWxlIChtYXRjaCkge1xuICAgIGNvbnN0IGFsbG1hdGNoZXMgPSBbXTtcbiAgICBhbGxtYXRjaGVzLnN0YXJ0SW5kZXggPSByZWdleC5sYXN0SW5kZXggLSBtYXRjaFswXS5sZW5ndGg7XG4gICAgY29uc3QgbGVuID0gbWF0Y2gubGVuZ3RoO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW47IGluZGV4KyspIHtcbiAgICAgIGFsbG1hdGNoZXMucHVzaChtYXRjaFtpbmRleF0pO1xuICAgIH1cbiAgICBtYXRjaGVzLnB1c2goYWxsbWF0Y2hlcyk7XG4gICAgbWF0Y2ggPSByZWdleC5leGVjKHN0cmluZyk7XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXM7XG59O1xuXG5jb25zdCBpc05hbWUgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgY29uc3QgbWF0Y2ggPSByZWdleE5hbWUuZXhlYyhzdHJpbmcpO1xuICByZXR1cm4gIShtYXRjaCA9PT0gbnVsbCB8fCB0eXBlb2YgbWF0Y2ggPT09ICd1bmRlZmluZWQnKTtcbn07XG5cbmV4cG9ydHMuaXNFeGlzdCA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIHR5cGVvZiB2ICE9PSAndW5kZWZpbmVkJztcbn07XG5cbmV4cG9ydHMuaXNFbXB0eU9iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDA7XG59O1xuXG4vKipcbiAqIENvcHkgYWxsIHRoZSBwcm9wZXJ0aWVzIG9mIGEgaW50byBiLlxuICogQHBhcmFtIHsqfSB0YXJnZXRcbiAqIEBwYXJhbSB7Kn0gYVxuICovXG5leHBvcnRzLm1lcmdlID0gZnVuY3Rpb24odGFyZ2V0LCBhLCBhcnJheU1vZGUpIHtcbiAgaWYgKGEpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYSk7IC8vIHdpbGwgcmV0dXJuIGFuIGFycmF5IG9mIG93biBwcm9wZXJ0aWVzXG4gICAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7IC8vZG9uJ3QgbWFrZSBpdCBpbmxpbmVcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoYXJyYXlNb2RlID09PSAnc3RyaWN0Jykge1xuICAgICAgICB0YXJnZXRba2V5c1tpXV0gPSBbIGFba2V5c1tpXV0gXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFtrZXlzW2ldXSA9IGFba2V5c1tpXV07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuLyogZXhwb3J0cy5tZXJnZSA9ZnVuY3Rpb24gKGIsYSl7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKGIsYSk7XG59ICovXG5cbmV4cG9ydHMuZ2V0VmFsdWUgPSBmdW5jdGlvbih2KSB7XG4gIGlmIChleHBvcnRzLmlzRXhpc3QodikpIHtcbiAgICByZXR1cm4gdjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbi8vIGNvbnN0IGZha2VDYWxsID0gZnVuY3Rpb24oYSkge3JldHVybiBhO307XG4vLyBjb25zdCBmYWtlQ2FsbE5vUmV0dXJuID0gZnVuY3Rpb24oKSB7fTtcblxuZXhwb3J0cy5pc05hbWUgPSBpc05hbWU7XG5leHBvcnRzLmdldEFsbE1hdGNoZXMgPSBnZXRBbGxNYXRjaGVzO1xuZXhwb3J0cy5uYW1lUmVnZXhwID0gbmFtZVJlZ2V4cDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-xml-parser/src/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/fast-xml-parser/src/validator.js":
/*!*******************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/validator.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/fast-xml-parser/src/util.js\");\n\nconst defaultOptions = {\n  allowBooleanAttributes: false, //A tag can have attributes without any value\n  unpairedTags: []\n};\n\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nexports.validate = function (xmlData, options) {\n  options = Object.assign({}, defaultOptions, options);\n\n  //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n  //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n  //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n  const tags = [];\n  let tagFound = false;\n\n  //indicates that the root tag has been closed (aka. depth 0 has been reached)\n  let reachedRoot = false;\n\n  if (xmlData[0] === '\\ufeff') {\n    // check for byte order mark (BOM)\n    xmlData = xmlData.substr(1);\n  }\n  \n  for (let i = 0; i < xmlData.length; i++) {\n\n    if (xmlData[i] === '<' && xmlData[i+1] === '?') {\n      i+=2;\n      i = readPI(xmlData,i);\n      if (i.err) return i;\n    }else if (xmlData[i] === '<') {\n      //starting of tag\n      //read until you reach to '>' avoiding any '>' in attribute value\n      let tagStartPos = i;\n      i++;\n      \n      if (xmlData[i] === '!') {\n        i = readCommentAndCDATA(xmlData, i);\n        continue;\n      } else {\n        let closingTag = false;\n        if (xmlData[i] === '/') {\n          //closing tag\n          closingTag = true;\n          i++;\n        }\n        //read tagname\n        let tagName = '';\n        for (; i < xmlData.length &&\n          xmlData[i] !== '>' &&\n          xmlData[i] !== ' ' &&\n          xmlData[i] !== '\\t' &&\n          xmlData[i] !== '\\n' &&\n          xmlData[i] !== '\\r'; i++\n        ) {\n          tagName += xmlData[i];\n        }\n        tagName = tagName.trim();\n        //console.log(tagName);\n\n        if (tagName[tagName.length - 1] === '/') {\n          //self closing tag without attributes\n          tagName = tagName.substring(0, tagName.length - 1);\n          //continue;\n          i--;\n        }\n        if (!validateTagName(tagName)) {\n          let msg;\n          if (tagName.trim().length === 0) {\n            msg = \"Invalid space after '<'.\";\n          } else {\n            msg = \"Tag '\"+tagName+\"' is an invalid name.\";\n          }\n          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));\n        }\n\n        const result = readAttributeStr(xmlData, i);\n        if (result === false) {\n          return getErrorObject('InvalidAttr', \"Attributes for '\"+tagName+\"' have open quote.\", getLineNumberForPosition(xmlData, i));\n        }\n        let attrStr = result.value;\n        i = result.index;\n\n        if (attrStr[attrStr.length - 1] === '/') {\n          //self closing tag\n          const attrStrStart = i - attrStr.length;\n          attrStr = attrStr.substring(0, attrStr.length - 1);\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid === true) {\n            tagFound = true;\n            //continue; //text may presents after self closing tag\n          } else {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));\n          }\n        } else if (closingTag) {\n          if (!result.tagClosed) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' doesn't have proper closing.\", getLineNumberForPosition(xmlData, i));\n          } else if (attrStr.trim().length > 0) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' can't have attributes or invalid starting.\", getLineNumberForPosition(xmlData, tagStartPos));\n          } else {\n            const otg = tags.pop();\n            if (tagName !== otg.tagName) {\n              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);\n              return getErrorObject('InvalidTag',\n                \"Expected closing tag '\"+otg.tagName+\"' (opened in line \"+openPos.line+\", col \"+openPos.col+\") instead of closing tag '\"+tagName+\"'.\",\n                getLineNumberForPosition(xmlData, tagStartPos));\n            }\n\n            //when there are no more tags, we reached the root level.\n            if (tags.length == 0) {\n              reachedRoot = true;\n            }\n          }\n        } else {\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid !== true) {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));\n          }\n\n          //if the root level has been reached before ...\n          if (reachedRoot === true) {\n            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));\n          } else if(options.unpairedTags.indexOf(tagName) !== -1){\n            //don't push into stack\n          } else {\n            tags.push({tagName, tagStartPos});\n          }\n          tagFound = true;\n        }\n\n        //skip tag text value\n        //It may include comments and CDATA value\n        for (i++; i < xmlData.length; i++) {\n          if (xmlData[i] === '<') {\n            if (xmlData[i + 1] === '!') {\n              //comment or CADATA\n              i++;\n              i = readCommentAndCDATA(xmlData, i);\n              continue;\n            } else if (xmlData[i+1] === '?') {\n              i = readPI(xmlData, ++i);\n              if (i.err) return i;\n            } else{\n              break;\n            }\n          } else if (xmlData[i] === '&') {\n            const afterAmp = validateAmpersand(xmlData, i);\n            if (afterAmp == -1)\n              return getErrorObject('InvalidChar', \"char '&' is not expected.\", getLineNumberForPosition(xmlData, i));\n            i = afterAmp;\n          }else{\n            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {\n              return getErrorObject('InvalidXml', \"Extra text at the end\", getLineNumberForPosition(xmlData, i));\n            }\n          }\n        } //end of reading tag text value\n        if (xmlData[i] === '<') {\n          i--;\n        }\n      }\n    } else {\n      if ( isWhiteSpace(xmlData[i])) {\n        continue;\n      }\n      return getErrorObject('InvalidChar', \"char '\"+xmlData[i]+\"' is not expected.\", getLineNumberForPosition(xmlData, i));\n    }\n  }\n\n  if (!tagFound) {\n    return getErrorObject('InvalidXml', 'Start tag expected.', 1);\n  }else if (tags.length == 1) {\n      return getErrorObject('InvalidTag', \"Unclosed tag '\"+tags[0].tagName+\"'.\", getLineNumberForPosition(xmlData, tags[0].tagStartPos));\n  }else if (tags.length > 0) {\n      return getErrorObject('InvalidXml', \"Invalid '\"+\n          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\\r?\\n/g, '')+\n          \"' found.\", {line: 1, col: 1});\n  }\n\n  return true;\n};\n\nfunction isWhiteSpace(char){\n  return char === ' ' || char === '\\t' || char === '\\n'  || char === '\\r';\n}\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */\nfunction readPI(xmlData, i) {\n  const start = i;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] == '?' || xmlData[i] == ' ') {\n      //tagname\n      const tagname = xmlData.substr(start, i - start);\n      if (i > 5 && tagname === 'xml') {\n        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));\n      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {\n        //check if valid attribut string\n        i++;\n        break;\n      } else {\n        continue;\n      }\n    }\n  }\n  return i;\n}\n\nfunction readCommentAndCDATA(xmlData, i) {\n  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {\n    //comment\n    for (i += 3; i < xmlData.length; i++) {\n      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  } else if (\n    xmlData.length > i + 8 &&\n    xmlData[i + 1] === 'D' &&\n    xmlData[i + 2] === 'O' &&\n    xmlData[i + 3] === 'C' &&\n    xmlData[i + 4] === 'T' &&\n    xmlData[i + 5] === 'Y' &&\n    xmlData[i + 6] === 'P' &&\n    xmlData[i + 7] === 'E'\n  ) {\n    let angleBracketsCount = 1;\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === '<') {\n        angleBracketsCount++;\n      } else if (xmlData[i] === '>') {\n        angleBracketsCount--;\n        if (angleBracketsCount === 0) {\n          break;\n        }\n      }\n    }\n  } else if (\n    xmlData.length > i + 9 &&\n    xmlData[i + 1] === '[' &&\n    xmlData[i + 2] === 'C' &&\n    xmlData[i + 3] === 'D' &&\n    xmlData[i + 4] === 'A' &&\n    xmlData[i + 5] === 'T' &&\n    xmlData[i + 6] === 'A' &&\n    xmlData[i + 7] === '['\n  ) {\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  }\n\n  return i;\n}\n\nconst doubleQuote = '\"';\nconst singleQuote = \"'\";\n\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */\nfunction readAttributeStr(xmlData, i) {\n  let attrStr = '';\n  let startChar = '';\n  let tagClosed = false;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n      if (startChar === '') {\n        startChar = xmlData[i];\n      } else if (startChar !== xmlData[i]) {\n        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n      } else {\n        startChar = '';\n      }\n    } else if (xmlData[i] === '>') {\n      if (startChar === '') {\n        tagClosed = true;\n        break;\n      }\n    }\n    attrStr += xmlData[i];\n  }\n  if (startChar !== '') {\n    return false;\n  }\n\n  return {\n    value: attrStr,\n    index: i,\n    tagClosed: tagClosed\n  };\n}\n\n/**\n * Select all the attributes whether valid or invalid.\n */\nconst validAttrStrRegxp = new RegExp('(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*([\\'\"])(([\\\\s\\\\S])*?)\\\\5)?', 'g');\n\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\n\nfunction validateAttributeString(attrStr, options) {\n  //console.log(\"start:\"+attrStr+\":end\");\n\n  //if(attrStr.trim().length === 0) return true; //empty string\n\n  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\n  const attrNames = {};\n\n  for (let i = 0; i < matches.length; i++) {\n    if (matches[i][1].length === 0) {\n      //nospace before attribute name: a=\"sd\"b=\"saf\"\n      return getErrorObject('InvalidAttr', \"Attribute '\"+matches[i][2]+\"' has no space in starting.\", getPositionFromMatch(matches[i]))\n    } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+matches[i][2]+\"' is without value.\", getPositionFromMatch(matches[i]));\n    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {\n      //independent attribute: ab\n      return getErrorObject('InvalidAttr', \"boolean attribute '\"+matches[i][2]+\"' is not allowed.\", getPositionFromMatch(matches[i]));\n    }\n    /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */\n    const attrName = matches[i][2];\n    if (!validateAttrName(attrName)) {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is an invalid name.\", getPositionFromMatch(matches[i]));\n    }\n    if (!attrNames.hasOwnProperty(attrName)) {\n      //check for duplicate attribute.\n      attrNames[attrName] = 1;\n    } else {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is repeated.\", getPositionFromMatch(matches[i]));\n    }\n  }\n\n  return true;\n}\n\nfunction validateNumberAmpersand(xmlData, i) {\n  let re = /\\d/;\n  if (xmlData[i] === 'x') {\n    i++;\n    re = /[\\da-fA-F]/;\n  }\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === ';')\n      return i;\n    if (!xmlData[i].match(re))\n      break;\n  }\n  return -1;\n}\n\nfunction validateAmpersand(xmlData, i) {\n  // https://www.w3.org/TR/xml/#dt-charref\n  i++;\n  if (xmlData[i] === ';')\n    return -1;\n  if (xmlData[i] === '#') {\n    i++;\n    return validateNumberAmpersand(xmlData, i);\n  }\n  let count = 0;\n  for (; i < xmlData.length; i++, count++) {\n    if (xmlData[i].match(/\\w/) && count < 20)\n      continue;\n    if (xmlData[i] === ';')\n      break;\n    return -1;\n  }\n  return i;\n}\n\nfunction getErrorObject(code, message, lineNumber) {\n  return {\n    err: {\n      code: code,\n      msg: message,\n      line: lineNumber.line || lineNumber,\n      col: lineNumber.col,\n    },\n  };\n}\n\nfunction validateAttrName(attrName) {\n  return util.isName(attrName);\n}\n\n// const startsWithXML = /^xml/i;\n\nfunction validateTagName(tagname) {\n  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;\n}\n\n//this function returns the line number for the character at the given index\nfunction getLineNumberForPosition(xmlData, index) {\n  const lines = xmlData.substring(0, index).split(/\\r?\\n/);\n  return {\n    line: lines.length,\n\n    // column number is last line's length + 1, because column numbering starts at 1:\n    col: lines[lines.length - 1].length + 1\n  };\n}\n\n//this function returns the position of the first character of match within attrStr\nfunction getPositionFromMatch(match) {\n  return match.startIndex + match[1].length;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy92YWxpZGF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLGdFQUFROztBQUU3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQiw0QkFBNEI7O0FBRTVCLG1EQUFtRDtBQUNuRCx3REFBd0Q7QUFDeEQsK0VBQStFO0FBQy9FO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1osdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9CQUFvQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0JBQW9CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlEQUFpRDs7QUFFakQ7QUFDQTs7QUFFQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsNkJBQTZCLE9BQU87QUFDcEMsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0JBQW9CO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0JBQW9CO0FBQzdCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2RpYXJ5LWZyb250LWVuZC8uL25vZGVfbW9kdWxlcy9mYXN0LXhtbC1wYXJzZXIvc3JjL3ZhbGlkYXRvci5qcz9jOTBmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgYWxsb3dCb29sZWFuQXR0cmlidXRlczogZmFsc2UsIC8vQSB0YWcgY2FuIGhhdmUgYXR0cmlidXRlcyB3aXRob3V0IGFueSB2YWx1ZVxuICB1bnBhaXJlZFRhZ3M6IFtdXG59O1xuXG4vL2NvbnN0IHRhZ3NQYXR0ZXJuID0gbmV3IFJlZ0V4cChcIjxcXFxcLz8oW1xcXFx3OlxcXFwtX1xcLl0rKVxcXFxzKlxcLz8+XCIsXCJnXCIpO1xuZXhwb3J0cy52YWxpZGF0ZSA9IGZ1bmN0aW9uICh4bWxEYXRhLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgLy94bWxEYXRhID0geG1sRGF0YS5yZXBsYWNlKC8oXFxyXFxufFxcbnxcXHIpL2dtLFwiXCIpOy8vbWFrZSBpdCBzaW5nbGUgbGluZVxuICAvL3htbERhdGEgPSB4bWxEYXRhLnJlcGxhY2UoLyheXFxzKjxcXD94bWwuKj9cXD8+KS9nLFwiXCIpOy8vUmVtb3ZlIFhNTCBzdGFydGluZyB0YWdcbiAgLy94bWxEYXRhID0geG1sRGF0YS5yZXBsYWNlKC8oPCFET0NUWVBFW1xcc1xcd1xcXCJcXC5cXC9cXC1cXDpdKyhcXFsuKlxcXSkqXFxzKj4pL2csXCJcIik7Ly9SZW1vdmUgRE9DVFlQRVxuICBjb25zdCB0YWdzID0gW107XG4gIGxldCB0YWdGb3VuZCA9IGZhbHNlO1xuXG4gIC8vaW5kaWNhdGVzIHRoYXQgdGhlIHJvb3QgdGFnIGhhcyBiZWVuIGNsb3NlZCAoYWthLiBkZXB0aCAwIGhhcyBiZWVuIHJlYWNoZWQpXG4gIGxldCByZWFjaGVkUm9vdCA9IGZhbHNlO1xuXG4gIGlmICh4bWxEYXRhWzBdID09PSAnXFx1ZmVmZicpIHtcbiAgICAvLyBjaGVjayBmb3IgYnl0ZSBvcmRlciBtYXJrIChCT00pXG4gICAgeG1sRGF0YSA9IHhtbERhdGEuc3Vic3RyKDEpO1xuICB9XG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHhtbERhdGEubGVuZ3RoOyBpKyspIHtcblxuICAgIGlmICh4bWxEYXRhW2ldID09PSAnPCcgJiYgeG1sRGF0YVtpKzFdID09PSAnPycpIHtcbiAgICAgIGkrPTI7XG4gICAgICBpID0gcmVhZFBJKHhtbERhdGEsaSk7XG4gICAgICBpZiAoaS5lcnIpIHJldHVybiBpO1xuICAgIH1lbHNlIGlmICh4bWxEYXRhW2ldID09PSAnPCcpIHtcbiAgICAgIC8vc3RhcnRpbmcgb2YgdGFnXG4gICAgICAvL3JlYWQgdW50aWwgeW91IHJlYWNoIHRvICc+JyBhdm9pZGluZyBhbnkgJz4nIGluIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAgbGV0IHRhZ1N0YXJ0UG9zID0gaTtcbiAgICAgIGkrKztcbiAgICAgIFxuICAgICAgaWYgKHhtbERhdGFbaV0gPT09ICchJykge1xuICAgICAgICBpID0gcmVhZENvbW1lbnRBbmRDREFUQSh4bWxEYXRhLCBpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgY2xvc2luZ1RhZyA9IGZhbHNlO1xuICAgICAgICBpZiAoeG1sRGF0YVtpXSA9PT0gJy8nKSB7XG4gICAgICAgICAgLy9jbG9zaW5nIHRhZ1xuICAgICAgICAgIGNsb3NpbmdUYWcgPSB0cnVlO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICAvL3JlYWQgdGFnbmFtZVxuICAgICAgICBsZXQgdGFnTmFtZSA9ICcnO1xuICAgICAgICBmb3IgKDsgaSA8IHhtbERhdGEubGVuZ3RoICYmXG4gICAgICAgICAgeG1sRGF0YVtpXSAhPT0gJz4nICYmXG4gICAgICAgICAgeG1sRGF0YVtpXSAhPT0gJyAnICYmXG4gICAgICAgICAgeG1sRGF0YVtpXSAhPT0gJ1xcdCcgJiZcbiAgICAgICAgICB4bWxEYXRhW2ldICE9PSAnXFxuJyAmJlxuICAgICAgICAgIHhtbERhdGFbaV0gIT09ICdcXHInOyBpKytcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGFnTmFtZSArPSB4bWxEYXRhW2ldO1xuICAgICAgICB9XG4gICAgICAgIHRhZ05hbWUgPSB0YWdOYW1lLnRyaW0oKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyh0YWdOYW1lKTtcblxuICAgICAgICBpZiAodGFnTmFtZVt0YWdOYW1lLmxlbmd0aCAtIDFdID09PSAnLycpIHtcbiAgICAgICAgICAvL3NlbGYgY2xvc2luZyB0YWcgd2l0aG91dCBhdHRyaWJ1dGVzXG4gICAgICAgICAgdGFnTmFtZSA9IHRhZ05hbWUuc3Vic3RyaW5nKDAsIHRhZ05hbWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgLy9jb250aW51ZTtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWxpZGF0ZVRhZ05hbWUodGFnTmFtZSkpIHtcbiAgICAgICAgICBsZXQgbXNnO1xuICAgICAgICAgIGlmICh0YWdOYW1lLnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG1zZyA9IFwiSW52YWxpZCBzcGFjZSBhZnRlciAnPCcuXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1zZyA9IFwiVGFnICdcIit0YWdOYW1lK1wiJyBpcyBhbiBpbnZhbGlkIG5hbWUuXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZFRhZycsIG1zZywgZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIGkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlYWRBdHRyaWJ1dGVTdHIoeG1sRGF0YSwgaSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkQXR0cicsIFwiQXR0cmlidXRlcyBmb3IgJ1wiK3RhZ05hbWUrXCInIGhhdmUgb3BlbiBxdW90ZS5cIiwgZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIGkpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYXR0clN0ciA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaSA9IHJlc3VsdC5pbmRleDtcblxuICAgICAgICBpZiAoYXR0clN0clthdHRyU3RyLmxlbmd0aCAtIDFdID09PSAnLycpIHtcbiAgICAgICAgICAvL3NlbGYgY2xvc2luZyB0YWdcbiAgICAgICAgICBjb25zdCBhdHRyU3RyU3RhcnQgPSBpIC0gYXR0clN0ci5sZW5ndGg7XG4gICAgICAgICAgYXR0clN0ciA9IGF0dHJTdHIuc3Vic3RyaW5nKDAsIGF0dHJTdHIubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgY29uc3QgaXNWYWxpZCA9IHZhbGlkYXRlQXR0cmlidXRlU3RyaW5nKGF0dHJTdHIsIG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChpc1ZhbGlkID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0YWdGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAvL2NvbnRpbnVlOyAvL3RleHQgbWF5IHByZXNlbnRzIGFmdGVyIHNlbGYgY2xvc2luZyB0YWdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy90aGUgcmVzdWx0IGZyb20gdGhlIG5lc3RlZCBmdW5jdGlvbiByZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgZXJyb3Igd2l0aGluIHRoZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgIC8vaW4gb3JkZXIgdG8gZ2V0IHRoZSAndHJ1ZScgZXJyb3IgbGluZSwgd2UgbmVlZCB0byBjYWxjdWxhdGUgdGhlIHBvc2l0aW9uIHdoZXJlIHRoZSBhdHRyaWJ1dGUgYmVnaW5zIChpIC0gYXR0clN0ci5sZW5ndGgpIGFuZCB0aGVuIGFkZCB0aGUgcG9zaXRpb24gd2l0aGluIHRoZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgIC8vdGhpcyBnaXZlcyB1cyB0aGUgYWJzb2x1dGUgaW5kZXggaW4gdGhlIGVudGlyZSB4bWwsIHdoaWNoIHdlIGNhbiB1c2UgdG8gZmluZCB0aGUgbGluZSBhdCBsYXN0XG4gICAgICAgICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoaXNWYWxpZC5lcnIuY29kZSwgaXNWYWxpZC5lcnIubXNnLCBnZXRMaW5lTnVtYmVyRm9yUG9zaXRpb24oeG1sRGF0YSwgYXR0clN0clN0YXJ0ICsgaXNWYWxpZC5lcnIubGluZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjbG9zaW5nVGFnKSB7XG4gICAgICAgICAgaWYgKCFyZXN1bHQudGFnQ2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRUYWcnLCBcIkNsb3NpbmcgdGFnICdcIit0YWdOYW1lK1wiJyBkb2Vzbid0IGhhdmUgcHJvcGVyIGNsb3NpbmcuXCIsIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCBpKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChhdHRyU3RyLnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRUYWcnLCBcIkNsb3NpbmcgdGFnICdcIit0YWdOYW1lK1wiJyBjYW4ndCBoYXZlIGF0dHJpYnV0ZXMgb3IgaW52YWxpZCBzdGFydGluZy5cIiwgZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIHRhZ1N0YXJ0UG9zKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG90ZyA9IHRhZ3MucG9wKCk7XG4gICAgICAgICAgICBpZiAodGFnTmFtZSAhPT0gb3RnLnRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgbGV0IG9wZW5Qb3MgPSBnZXRMaW5lTnVtYmVyRm9yUG9zaXRpb24oeG1sRGF0YSwgb3RnLnRhZ1N0YXJ0UG9zKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkVGFnJyxcbiAgICAgICAgICAgICAgICBcIkV4cGVjdGVkIGNsb3NpbmcgdGFnICdcIitvdGcudGFnTmFtZStcIicgKG9wZW5lZCBpbiBsaW5lIFwiK29wZW5Qb3MubGluZStcIiwgY29sIFwiK29wZW5Qb3MuY29sK1wiKSBpbnN0ZWFkIG9mIGNsb3NpbmcgdGFnICdcIit0YWdOYW1lK1wiJy5cIixcbiAgICAgICAgICAgICAgICBnZXRMaW5lTnVtYmVyRm9yUG9zaXRpb24oeG1sRGF0YSwgdGFnU3RhcnRQb3MpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy93aGVuIHRoZXJlIGFyZSBubyBtb3JlIHRhZ3MsIHdlIHJlYWNoZWQgdGhlIHJvb3QgbGV2ZWwuXG4gICAgICAgICAgICBpZiAodGFncy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICByZWFjaGVkUm9vdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSB2YWxpZGF0ZUF0dHJpYnV0ZVN0cmluZyhhdHRyU3RyLCBvcHRpb25zKTtcbiAgICAgICAgICBpZiAoaXNWYWxpZCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy90aGUgcmVzdWx0IGZyb20gdGhlIG5lc3RlZCBmdW5jdGlvbiByZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgZXJyb3Igd2l0aGluIHRoZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgIC8vaW4gb3JkZXIgdG8gZ2V0IHRoZSAndHJ1ZScgZXJyb3IgbGluZSwgd2UgbmVlZCB0byBjYWxjdWxhdGUgdGhlIHBvc2l0aW9uIHdoZXJlIHRoZSBhdHRyaWJ1dGUgYmVnaW5zIChpIC0gYXR0clN0ci5sZW5ndGgpIGFuZCB0aGVuIGFkZCB0aGUgcG9zaXRpb24gd2l0aGluIHRoZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgIC8vdGhpcyBnaXZlcyB1cyB0aGUgYWJzb2x1dGUgaW5kZXggaW4gdGhlIGVudGlyZSB4bWwsIHdoaWNoIHdlIGNhbiB1c2UgdG8gZmluZCB0aGUgbGluZSBhdCBsYXN0XG4gICAgICAgICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoaXNWYWxpZC5lcnIuY29kZSwgaXNWYWxpZC5lcnIubXNnLCBnZXRMaW5lTnVtYmVyRm9yUG9zaXRpb24oeG1sRGF0YSwgaSAtIGF0dHJTdHIubGVuZ3RoICsgaXNWYWxpZC5lcnIubGluZSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vaWYgdGhlIHJvb3QgbGV2ZWwgaGFzIGJlZW4gcmVhY2hlZCBiZWZvcmUgLi4uXG4gICAgICAgICAgaWYgKHJlYWNoZWRSb290ID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRYbWwnLCAnTXVsdGlwbGUgcG9zc2libGUgcm9vdCBub2RlcyBmb3VuZC4nLCBnZXRMaW5lTnVtYmVyRm9yUG9zaXRpb24oeG1sRGF0YSwgaSkpO1xuICAgICAgICAgIH0gZWxzZSBpZihvcHRpb25zLnVucGFpcmVkVGFncy5pbmRleE9mKHRhZ05hbWUpICE9PSAtMSl7XG4gICAgICAgICAgICAvL2Rvbid0IHB1c2ggaW50byBzdGFja1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YWdzLnB1c2goe3RhZ05hbWUsIHRhZ1N0YXJ0UG9zfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhZ0ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vc2tpcCB0YWcgdGV4dCB2YWx1ZVxuICAgICAgICAvL0l0IG1heSBpbmNsdWRlIGNvbW1lbnRzIGFuZCBDREFUQSB2YWx1ZVxuICAgICAgICBmb3IgKGkrKzsgaSA8IHhtbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoeG1sRGF0YVtpXSA9PT0gJzwnKSB7XG4gICAgICAgICAgICBpZiAoeG1sRGF0YVtpICsgMV0gPT09ICchJykge1xuICAgICAgICAgICAgICAvL2NvbW1lbnQgb3IgQ0FEQVRBXG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgaSA9IHJlYWRDb21tZW50QW5kQ0RBVEEoeG1sRGF0YSwgaSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh4bWxEYXRhW2krMV0gPT09ICc/Jykge1xuICAgICAgICAgICAgICBpID0gcmVhZFBJKHhtbERhdGEsICsraSk7XG4gICAgICAgICAgICAgIGlmIChpLmVycikgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2V7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoeG1sRGF0YVtpXSA9PT0gJyYnKSB7XG4gICAgICAgICAgICBjb25zdCBhZnRlckFtcCA9IHZhbGlkYXRlQW1wZXJzYW5kKHhtbERhdGEsIGkpO1xuICAgICAgICAgICAgaWYgKGFmdGVyQW1wID09IC0xKVxuICAgICAgICAgICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRDaGFyJywgXCJjaGFyICcmJyBpcyBub3QgZXhwZWN0ZWQuXCIsIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCBpKSk7XG4gICAgICAgICAgICBpID0gYWZ0ZXJBbXA7XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBpZiAocmVhY2hlZFJvb3QgPT09IHRydWUgJiYgIWlzV2hpdGVTcGFjZSh4bWxEYXRhW2ldKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRYbWwnLCBcIkV4dHJhIHRleHQgYXQgdGhlIGVuZFwiLCBnZXRMaW5lTnVtYmVyRm9yUG9zaXRpb24oeG1sRGF0YSwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvL2VuZCBvZiByZWFkaW5nIHRhZyB0ZXh0IHZhbHVlXG4gICAgICAgIGlmICh4bWxEYXRhW2ldID09PSAnPCcpIHtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCBpc1doaXRlU3BhY2UoeG1sRGF0YVtpXSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRDaGFyJywgXCJjaGFyICdcIit4bWxEYXRhW2ldK1wiJyBpcyBub3QgZXhwZWN0ZWQuXCIsIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCBpKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0YWdGb3VuZCkge1xuICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZFhtbCcsICdTdGFydCB0YWcgZXhwZWN0ZWQuJywgMSk7XG4gIH1lbHNlIGlmICh0YWdzLmxlbmd0aCA9PSAxKSB7XG4gICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRUYWcnLCBcIlVuY2xvc2VkIHRhZyAnXCIrdGFnc1swXS50YWdOYW1lK1wiJy5cIiwgZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIHRhZ3NbMF0udGFnU3RhcnRQb3MpKTtcbiAgfWVsc2UgaWYgKHRhZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkWG1sJywgXCJJbnZhbGlkICdcIitcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeSh0YWdzLm1hcCh0ID0+IHQudGFnTmFtZSksIG51bGwsIDQpLnJlcGxhY2UoL1xccj9cXG4vZywgJycpK1xuICAgICAgICAgIFwiJyBmb3VuZC5cIiwge2xpbmU6IDEsIGNvbDogMX0pO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBpc1doaXRlU3BhY2UoY2hhcil7XG4gIHJldHVybiBjaGFyID09PSAnICcgfHwgY2hhciA9PT0gJ1xcdCcgfHwgY2hhciA9PT0gJ1xcbicgIHx8IGNoYXIgPT09ICdcXHInO1xufVxuLyoqXG4gKiBSZWFkIFByb2Nlc3NpbmcgaW5zc3RydWN0aW9ucyBhbmQgc2tpcFxuICogQHBhcmFtIHsqfSB4bWxEYXRhXG4gKiBAcGFyYW0geyp9IGlcbiAqL1xuZnVuY3Rpb24gcmVhZFBJKHhtbERhdGEsIGkpIHtcbiAgY29uc3Qgc3RhcnQgPSBpO1xuICBmb3IgKDsgaSA8IHhtbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoeG1sRGF0YVtpXSA9PSAnPycgfHwgeG1sRGF0YVtpXSA9PSAnICcpIHtcbiAgICAgIC8vdGFnbmFtZVxuICAgICAgY29uc3QgdGFnbmFtZSA9IHhtbERhdGEuc3Vic3RyKHN0YXJ0LCBpIC0gc3RhcnQpO1xuICAgICAgaWYgKGkgPiA1ICYmIHRhZ25hbWUgPT09ICd4bWwnKSB7XG4gICAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZFhtbCcsICdYTUwgZGVjbGFyYXRpb24gYWxsb3dlZCBvbmx5IGF0IHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQuJywgZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIGkpKTtcbiAgICAgIH0gZWxzZSBpZiAoeG1sRGF0YVtpXSA9PSAnPycgJiYgeG1sRGF0YVtpICsgMV0gPT0gJz4nKSB7XG4gICAgICAgIC8vY2hlY2sgaWYgdmFsaWQgYXR0cmlidXQgc3RyaW5nXG4gICAgICAgIGkrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5cbmZ1bmN0aW9uIHJlYWRDb21tZW50QW5kQ0RBVEEoeG1sRGF0YSwgaSkge1xuICBpZiAoeG1sRGF0YS5sZW5ndGggPiBpICsgNSAmJiB4bWxEYXRhW2kgKyAxXSA9PT0gJy0nICYmIHhtbERhdGFbaSArIDJdID09PSAnLScpIHtcbiAgICAvL2NvbW1lbnRcbiAgICBmb3IgKGkgKz0gMzsgaSA8IHhtbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh4bWxEYXRhW2ldID09PSAnLScgJiYgeG1sRGF0YVtpICsgMV0gPT09ICctJyAmJiB4bWxEYXRhW2kgKyAyXSA9PT0gJz4nKSB7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKFxuICAgIHhtbERhdGEubGVuZ3RoID4gaSArIDggJiZcbiAgICB4bWxEYXRhW2kgKyAxXSA9PT0gJ0QnICYmXG4gICAgeG1sRGF0YVtpICsgMl0gPT09ICdPJyAmJlxuICAgIHhtbERhdGFbaSArIDNdID09PSAnQycgJiZcbiAgICB4bWxEYXRhW2kgKyA0XSA9PT0gJ1QnICYmXG4gICAgeG1sRGF0YVtpICsgNV0gPT09ICdZJyAmJlxuICAgIHhtbERhdGFbaSArIDZdID09PSAnUCcgJiZcbiAgICB4bWxEYXRhW2kgKyA3XSA9PT0gJ0UnXG4gICkge1xuICAgIGxldCBhbmdsZUJyYWNrZXRzQ291bnQgPSAxO1xuICAgIGZvciAoaSArPSA4OyBpIDwgeG1sRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHhtbERhdGFbaV0gPT09ICc8Jykge1xuICAgICAgICBhbmdsZUJyYWNrZXRzQ291bnQrKztcbiAgICAgIH0gZWxzZSBpZiAoeG1sRGF0YVtpXSA9PT0gJz4nKSB7XG4gICAgICAgIGFuZ2xlQnJhY2tldHNDb3VudC0tO1xuICAgICAgICBpZiAoYW5nbGVCcmFja2V0c0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoXG4gICAgeG1sRGF0YS5sZW5ndGggPiBpICsgOSAmJlxuICAgIHhtbERhdGFbaSArIDFdID09PSAnWycgJiZcbiAgICB4bWxEYXRhW2kgKyAyXSA9PT0gJ0MnICYmXG4gICAgeG1sRGF0YVtpICsgM10gPT09ICdEJyAmJlxuICAgIHhtbERhdGFbaSArIDRdID09PSAnQScgJiZcbiAgICB4bWxEYXRhW2kgKyA1XSA9PT0gJ1QnICYmXG4gICAgeG1sRGF0YVtpICsgNl0gPT09ICdBJyAmJlxuICAgIHhtbERhdGFbaSArIDddID09PSAnWydcbiAgKSB7XG4gICAgZm9yIChpICs9IDg7IGkgPCB4bWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoeG1sRGF0YVtpXSA9PT0gJ10nICYmIHhtbERhdGFbaSArIDFdID09PSAnXScgJiYgeG1sRGF0YVtpICsgMl0gPT09ICc+Jykge1xuICAgICAgICBpICs9IDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpO1xufVxuXG5jb25zdCBkb3VibGVRdW90ZSA9ICdcIic7XG5jb25zdCBzaW5nbGVRdW90ZSA9IFwiJ1wiO1xuXG4vKipcbiAqIEtlZXAgcmVhZGluZyB4bWxEYXRhIHVudGlsICc8JyBpcyBmb3VuZCBvdXRzaWRlIHRoZSBhdHRyaWJ1dGUgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30geG1sRGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IGlcbiAqL1xuZnVuY3Rpb24gcmVhZEF0dHJpYnV0ZVN0cih4bWxEYXRhLCBpKSB7XG4gIGxldCBhdHRyU3RyID0gJyc7XG4gIGxldCBzdGFydENoYXIgPSAnJztcbiAgbGV0IHRhZ0Nsb3NlZCA9IGZhbHNlO1xuICBmb3IgKDsgaSA8IHhtbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoeG1sRGF0YVtpXSA9PT0gZG91YmxlUXVvdGUgfHwgeG1sRGF0YVtpXSA9PT0gc2luZ2xlUXVvdGUpIHtcbiAgICAgIGlmIChzdGFydENoYXIgPT09ICcnKSB7XG4gICAgICAgIHN0YXJ0Q2hhciA9IHhtbERhdGFbaV07XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0Q2hhciAhPT0geG1sRGF0YVtpXSkge1xuICAgICAgICAvL2lmIHZhdWUgaXMgZW5jbG9zZWQgd2l0aCBkb3VibGUgcXVvdGUgdGhlbiBzaW5nbGUgcXVvdGVzIGFyZSBhbGxvd2VkIGluc2lkZSB0aGUgdmFsdWUgYW5kIHZpY2UgdmVyc2FcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0Q2hhciA9ICcnO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoeG1sRGF0YVtpXSA9PT0gJz4nKSB7XG4gICAgICBpZiAoc3RhcnRDaGFyID09PSAnJykge1xuICAgICAgICB0YWdDbG9zZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgYXR0clN0ciArPSB4bWxEYXRhW2ldO1xuICB9XG4gIGlmIChzdGFydENoYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogYXR0clN0cixcbiAgICBpbmRleDogaSxcbiAgICB0YWdDbG9zZWQ6IHRhZ0Nsb3NlZFxuICB9O1xufVxuXG4vKipcbiAqIFNlbGVjdCBhbGwgdGhlIGF0dHJpYnV0ZXMgd2hldGhlciB2YWxpZCBvciBpbnZhbGlkLlxuICovXG5jb25zdCB2YWxpZEF0dHJTdHJSZWd4cCA9IG5ldyBSZWdFeHAoJyhcXFxccyopKFteXFxcXHM9XSspKFxcXFxzKj0pPyhcXFxccyooW1xcJ1wiXSkoKFtcXFxcc1xcXFxTXSkqPylcXFxcNSk/JywgJ2cnKTtcblxuLy9hdHRyLCA9XCJzZFwiLCBhPVwiYW1pdCdzXCIsIGE9XCJzZFwiYj1cInNhZlwiLCBhYiAgY2Q9XCJcIlxuXG5mdW5jdGlvbiB2YWxpZGF0ZUF0dHJpYnV0ZVN0cmluZyhhdHRyU3RyLCBvcHRpb25zKSB7XG4gIC8vY29uc29sZS5sb2coXCJzdGFydDpcIithdHRyU3RyK1wiOmVuZFwiKTtcblxuICAvL2lmKGF0dHJTdHIudHJpbSgpLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWU7IC8vZW1wdHkgc3RyaW5nXG5cbiAgY29uc3QgbWF0Y2hlcyA9IHV0aWwuZ2V0QWxsTWF0Y2hlcyhhdHRyU3RyLCB2YWxpZEF0dHJTdHJSZWd4cCk7XG4gIGNvbnN0IGF0dHJOYW1lcyA9IHt9O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChtYXRjaGVzW2ldWzFdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy9ub3NwYWNlIGJlZm9yZSBhdHRyaWJ1dGUgbmFtZTogYT1cInNkXCJiPVwic2FmXCJcbiAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZEF0dHInLCBcIkF0dHJpYnV0ZSAnXCIrbWF0Y2hlc1tpXVsyXStcIicgaGFzIG5vIHNwYWNlIGluIHN0YXJ0aW5nLlwiLCBnZXRQb3NpdGlvbkZyb21NYXRjaChtYXRjaGVzW2ldKSlcbiAgICB9IGVsc2UgaWYgKG1hdGNoZXNbaV1bM10gIT09IHVuZGVmaW5lZCAmJiBtYXRjaGVzW2ldWzRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZEF0dHInLCBcIkF0dHJpYnV0ZSAnXCIrbWF0Y2hlc1tpXVsyXStcIicgaXMgd2l0aG91dCB2YWx1ZS5cIiwgZ2V0UG9zaXRpb25Gcm9tTWF0Y2gobWF0Y2hlc1tpXSkpO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hlc1tpXVszXSA9PT0gdW5kZWZpbmVkICYmICFvcHRpb25zLmFsbG93Qm9vbGVhbkF0dHJpYnV0ZXMpIHtcbiAgICAgIC8vaW5kZXBlbmRlbnQgYXR0cmlidXRlOiBhYlxuICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkQXR0cicsIFwiYm9vbGVhbiBhdHRyaWJ1dGUgJ1wiK21hdGNoZXNbaV1bMl0rXCInIGlzIG5vdCBhbGxvd2VkLlwiLCBnZXRQb3NpdGlvbkZyb21NYXRjaChtYXRjaGVzW2ldKSk7XG4gICAgfVxuICAgIC8qIGVsc2UgaWYobWF0Y2hlc1tpXVs2XSA9PT0gdW5kZWZpbmVkKXsvL2F0dHJpYnV0ZSB3aXRob3V0IHZhbHVlOiBhYj1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyOiB7IGNvZGU6XCJJbnZhbGlkQXR0clwiLG1zZzpcImF0dHJpYnV0ZSBcIiArIG1hdGNoZXNbaV1bMl0gKyBcIiBoYXMgbm8gdmFsdWUgYXNzaWduZWQuXCJ9fTtcbiAgICAgICAgICAgICAgICB9ICovXG4gICAgY29uc3QgYXR0ck5hbWUgPSBtYXRjaGVzW2ldWzJdO1xuICAgIGlmICghdmFsaWRhdGVBdHRyTmFtZShhdHRyTmFtZSkpIHtcbiAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZEF0dHInLCBcIkF0dHJpYnV0ZSAnXCIrYXR0ck5hbWUrXCInIGlzIGFuIGludmFsaWQgbmFtZS5cIiwgZ2V0UG9zaXRpb25Gcm9tTWF0Y2gobWF0Y2hlc1tpXSkpO1xuICAgIH1cbiAgICBpZiAoIWF0dHJOYW1lcy5oYXNPd25Qcm9wZXJ0eShhdHRyTmFtZSkpIHtcbiAgICAgIC8vY2hlY2sgZm9yIGR1cGxpY2F0ZSBhdHRyaWJ1dGUuXG4gICAgICBhdHRyTmFtZXNbYXR0ck5hbWVdID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkQXR0cicsIFwiQXR0cmlidXRlICdcIithdHRyTmFtZStcIicgaXMgcmVwZWF0ZWQuXCIsIGdldFBvc2l0aW9uRnJvbU1hdGNoKG1hdGNoZXNbaV0pKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXJBbXBlcnNhbmQoeG1sRGF0YSwgaSkge1xuICBsZXQgcmUgPSAvXFxkLztcbiAgaWYgKHhtbERhdGFbaV0gPT09ICd4Jykge1xuICAgIGkrKztcbiAgICByZSA9IC9bXFxkYS1mQS1GXS87XG4gIH1cbiAgZm9yICg7IGkgPCB4bWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHhtbERhdGFbaV0gPT09ICc7JylcbiAgICAgIHJldHVybiBpO1xuICAgIGlmICgheG1sRGF0YVtpXS5tYXRjaChyZSkpXG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQW1wZXJzYW5kKHhtbERhdGEsIGkpIHtcbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3htbC8jZHQtY2hhcnJlZlxuICBpKys7XG4gIGlmICh4bWxEYXRhW2ldID09PSAnOycpXG4gICAgcmV0dXJuIC0xO1xuICBpZiAoeG1sRGF0YVtpXSA9PT0gJyMnKSB7XG4gICAgaSsrO1xuICAgIHJldHVybiB2YWxpZGF0ZU51bWJlckFtcGVyc2FuZCh4bWxEYXRhLCBpKTtcbiAgfVxuICBsZXQgY291bnQgPSAwO1xuICBmb3IgKDsgaSA8IHhtbERhdGEubGVuZ3RoOyBpKyssIGNvdW50KyspIHtcbiAgICBpZiAoeG1sRGF0YVtpXS5tYXRjaCgvXFx3LykgJiYgY291bnQgPCAyMClcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmICh4bWxEYXRhW2ldID09PSAnOycpXG4gICAgICBicmVhaztcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5cbmZ1bmN0aW9uIGdldEVycm9yT2JqZWN0KGNvZGUsIG1lc3NhZ2UsIGxpbmVOdW1iZXIpIHtcbiAgcmV0dXJuIHtcbiAgICBlcnI6IHtcbiAgICAgIGNvZGU6IGNvZGUsXG4gICAgICBtc2c6IG1lc3NhZ2UsXG4gICAgICBsaW5lOiBsaW5lTnVtYmVyLmxpbmUgfHwgbGluZU51bWJlcixcbiAgICAgIGNvbDogbGluZU51bWJlci5jb2wsXG4gICAgfSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVBdHRyTmFtZShhdHRyTmFtZSkge1xuICByZXR1cm4gdXRpbC5pc05hbWUoYXR0ck5hbWUpO1xufVxuXG4vLyBjb25zdCBzdGFydHNXaXRoWE1MID0gL154bWwvaTtcblxuZnVuY3Rpb24gdmFsaWRhdGVUYWdOYW1lKHRhZ25hbWUpIHtcbiAgcmV0dXJuIHV0aWwuaXNOYW1lKHRhZ25hbWUpIC8qICYmICF0YWduYW1lLm1hdGNoKHN0YXJ0c1dpdGhYTUwpICovO1xufVxuXG4vL3RoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgbGluZSBudW1iZXIgZm9yIHRoZSBjaGFyYWN0ZXIgYXQgdGhlIGdpdmVuIGluZGV4XG5mdW5jdGlvbiBnZXRMaW5lTnVtYmVyRm9yUG9zaXRpb24oeG1sRGF0YSwgaW5kZXgpIHtcbiAgY29uc3QgbGluZXMgPSB4bWxEYXRhLnN1YnN0cmluZygwLCBpbmRleCkuc3BsaXQoL1xccj9cXG4vKTtcbiAgcmV0dXJuIHtcbiAgICBsaW5lOiBsaW5lcy5sZW5ndGgsXG5cbiAgICAvLyBjb2x1bW4gbnVtYmVyIGlzIGxhc3QgbGluZSdzIGxlbmd0aCArIDEsIGJlY2F1c2UgY29sdW1uIG51bWJlcmluZyBzdGFydHMgYXQgMTpcbiAgICBjb2w6IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aCArIDFcbiAgfTtcbn1cblxuLy90aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgbWF0Y2ggd2l0aGluIGF0dHJTdHJcbmZ1bmN0aW9uIGdldFBvc2l0aW9uRnJvbU1hdGNoKG1hdGNoKSB7XG4gIHJldHVybiBtYXRjaC5zdGFydEluZGV4ICsgbWF0Y2hbMV0ubGVuZ3RoO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-xml-parser/src/validator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js":
/*!*****************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n//parse Empty Node as self closing node\nconst buildFromOrderedJs = __webpack_require__(/*! ./orderedJs2Xml */ \"(ssr)/./node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js\");\n\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attributesGroupName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  cdataPropName: false,\n  format: false,\n  indentBy: '  ',\n  suppressEmptyNode: false,\n  suppressUnpairedNode: true,\n  suppressBooleanAttributes: true,\n  tagValueProcessor: function(key, a) {\n    return a;\n  },\n  attributeValueProcessor: function(attrName, a) {\n    return a;\n  },\n  preserveOrder: false,\n  commentPropName: false,\n  unpairedTags: [],\n  entities: [\n    { regex: new RegExp(\"&\", \"g\"), val: \"&amp;\" },//it must be on top\n    { regex: new RegExp(\">\", \"g\"), val: \"&gt;\" },\n    { regex: new RegExp(\"<\", \"g\"), val: \"&lt;\" },\n    { regex: new RegExp(\"\\'\", \"g\"), val: \"&apos;\" },\n    { regex: new RegExp(\"\\\"\", \"g\"), val: \"&quot;\" }\n  ],\n  processEntities: true,\n  stopNodes: [],\n  // transformTagName: false,\n  // transformAttributeName: false,\n  oneListGroup: false\n};\n\nfunction Builder(options) {\n  this.options = Object.assign({}, defaultOptions, options);\n  if (this.options.ignoreAttributes || this.options.attributesGroupName) {\n    this.isAttribute = function(/*a*/) {\n      return false;\n    };\n  } else {\n    this.attrPrefixLen = this.options.attributeNamePrefix.length;\n    this.isAttribute = isAttribute;\n  }\n\n  this.processTextOrObjNode = processTextOrObjNode\n\n  if (this.options.format) {\n    this.indentate = indentate;\n    this.tagEndChar = '>\\n';\n    this.newLine = '\\n';\n  } else {\n    this.indentate = function() {\n      return '';\n    };\n    this.tagEndChar = '>';\n    this.newLine = '';\n  }\n}\n\nBuilder.prototype.build = function(jObj) {\n  if(this.options.preserveOrder){\n    return buildFromOrderedJs(jObj, this.options);\n  }else {\n    if(Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1){\n      jObj = {\n        [this.options.arrayNodeName] : jObj\n      }\n    }\n    return this.j2x(jObj, 0).val;\n  }\n};\n\nBuilder.prototype.j2x = function(jObj, level) {\n  let attrStr = '';\n  let val = '';\n  for (let key in jObj) {\n    if(!jObj.hasOwnProperty(key)) continue;\n    if (typeof jObj[key] === 'undefined') {\n      // supress undefined node only if it is not an attribute\n      if (this.isAttribute(key)) {\n        val += '';\n      }\n    } else if (jObj[key] === null) {\n      // null attribute should be ignored by the attribute list, but should not cause the tag closing\n      if (this.isAttribute(key)) {\n        val += '';\n      } else if (key[0] === '?') {\n        val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;\n      } else {\n        val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n      }\n      // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n    } else if (jObj[key] instanceof Date) {\n      val += this.buildTextValNode(jObj[key], key, '', level);\n    } else if (typeof jObj[key] !== 'object') {\n      //premitive type\n      const attr = this.isAttribute(key);\n      if (attr) {\n        attrStr += this.buildAttrPairStr(attr, '' + jObj[key]);\n      }else {\n        //tag value\n        if (key === this.options.textNodeName) {\n          let newval = this.options.tagValueProcessor(key, '' + jObj[key]);\n          val += this.replaceEntitiesValue(newval);\n        } else {\n          val += this.buildTextValNode(jObj[key], key, '', level);\n        }\n      }\n    } else if (Array.isArray(jObj[key])) {\n      //repeated nodes\n      const arrLen = jObj[key].length;\n      let listTagVal = \"\";\n      for (let j = 0; j < arrLen; j++) {\n        const item = jObj[key][j];\n        if (typeof item === 'undefined') {\n          // supress undefined node\n        } else if (item === null) {\n          if(key[0] === \"?\") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;\n          else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n          // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n        } else if (typeof item === 'object') {\n          if(this.options.oneListGroup ){\n            listTagVal += this.j2x(item, level + 1).val;\n          }else{\n            listTagVal += this.processTextOrObjNode(item, key, level)\n          }\n        } else {\n          listTagVal += this.buildTextValNode(item, key, '', level);\n        }\n      }\n      if(this.options.oneListGroup){\n        listTagVal = this.buildObjectNode(listTagVal, key, '', level);\n      }\n      val += listTagVal;\n    } else {\n      //nested node\n      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {\n        const Ks = Object.keys(jObj[key]);\n        const L = Ks.length;\n        for (let j = 0; j < L; j++) {\n          attrStr += this.buildAttrPairStr(Ks[j], '' + jObj[key][Ks[j]]);\n        }\n      } else {\n        val += this.processTextOrObjNode(jObj[key], key, level)\n      }\n    }\n  }\n  return {attrStr: attrStr, val: val};\n};\n\nBuilder.prototype.buildAttrPairStr = function(attrName, val){\n  val = this.options.attributeValueProcessor(attrName, '' + val);\n  val = this.replaceEntitiesValue(val);\n  if (this.options.suppressBooleanAttributes && val === \"true\") {\n    return ' ' + attrName;\n  } else return ' ' + attrName + '=\"' + val + '\"';\n}\n\nfunction processTextOrObjNode (object, key, level) {\n  const result = this.j2x(object, level + 1);\n  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {\n    return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);\n  } else {\n    return this.buildObjectNode(result.val, key, result.attrStr, level);\n  }\n}\n\nBuilder.prototype.buildObjectNode = function(val, key, attrStr, level) {\n  if(val === \"\"){\n    if(key[0] === \"?\") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;\n    else {\n      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;\n    }\n  }else{\n\n    let tagEndExp = '</' + key + this.tagEndChar;\n    let piClosingChar = \"\";\n    \n    if(key[0] === \"?\") {\n      piClosingChar = \"?\";\n      tagEndExp = \"\";\n    }\n  \n    // attrStr is an empty string in case the attribute came as undefined or null\n    if ((attrStr || attrStr === '') && val.indexOf('<') === -1) {\n      return ( this.indentate(level) + '<' +  key + attrStr + piClosingChar + '>' + val + tagEndExp );\n    } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {\n      return this.indentate(level) + `<!--${val}-->` + this.newLine;\n    }else {\n      return (\n        this.indentate(level) + '<' + key + attrStr + piClosingChar + this.tagEndChar +\n        val +\n        this.indentate(level) + tagEndExp    );\n    }\n  }\n}\n\nBuilder.prototype.closeTag = function(key){\n  let closeTag = \"\";\n  if(this.options.unpairedTags.indexOf(key) !== -1){ //unpaired\n    if(!this.options.suppressUnpairedNode) closeTag = \"/\"\n  }else if(this.options.suppressEmptyNode){ //empty\n    closeTag = \"/\";\n  }else{\n    closeTag = `></${key}`\n  }\n  return closeTag;\n}\n\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n  if (val !== '') {\n    return this.buildObjectNode(val, key, attrStr, level);\n  } else {\n    if(key[0] === \"?\") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;\n    else {\n      return  this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;\n      // return this.buildTagStr(level,key, attrStr);\n    }\n  }\n}\n\nBuilder.prototype.buildTextValNode = function(val, key, attrStr, level) {\n  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {\n    return this.indentate(level) + `<![CDATA[${val}]]>` +  this.newLine;\n  }else if (this.options.commentPropName !== false && key === this.options.commentPropName) {\n    return this.indentate(level) + `<!--${val}-->` +  this.newLine;\n  }else if(key[0] === \"?\") {//PI tag\n    return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar; \n  }else{\n    let textValue = this.options.tagValueProcessor(key, val);\n    textValue = this.replaceEntitiesValue(textValue);\n  \n    if( textValue === ''){\n      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;\n    }else{\n      return this.indentate(level) + '<' + key + attrStr + '>' +\n         textValue +\n        '</' + key + this.tagEndChar;\n    }\n  }\n}\n\nBuilder.prototype.replaceEntitiesValue = function(textValue){\n  if(textValue && textValue.length > 0 && this.options.processEntities){\n    for (let i=0; i<this.options.entities.length; i++) {\n      const entity = this.options.entities[i];\n      textValue = textValue.replace(entity.regex, entity.val);\n    }\n  }\n  return textValue;\n}\n\nfunction indentate(level) {\n  return this.options.indentBy.repeat(level);\n}\n\nfunction isAttribute(name /*, options*/) {\n  if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {\n    return name.substr(this.attrPrefixLen);\n  } else {\n    return false;\n  }\n}\n\nmodule.exports = Builder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxidWlsZGVyL2pzb24yeG1sLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSwyQkFBMkIsbUJBQU8sQ0FBQyw2RkFBaUI7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHdDQUF3QyxHQUFHO0FBQ2pELE1BQU0sdUNBQXVDLEdBQUc7QUFDaEQsTUFBTSx1Q0FBdUMsR0FBRztBQUNoRCxNQUFNLDBDQUEwQyxHQUFHO0FBQ25ELE1BQU0sMENBQTBDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRDQUE0QyxJQUFJO0FBQ2hELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EsR0FBRyx5Q0FBeUM7QUFDNUM7QUFDQSxHQUFHO0FBQ0gscUJBQXFCLElBQUk7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLElBQUk7QUFDbkQsR0FBRztBQUNILDBDQUEwQyxJQUFJO0FBQzlDLEdBQUcseUJBQXlCO0FBQzVCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0NBQWdDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2RpYXJ5LWZyb250LWVuZC8uL25vZGVfbW9kdWxlcy9mYXN0LXhtbC1wYXJzZXIvc3JjL3htbGJ1aWxkZXIvanNvbjJ4bWwuanM/YjIwMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vL3BhcnNlIEVtcHR5IE5vZGUgYXMgc2VsZiBjbG9zaW5nIG5vZGVcbmNvbnN0IGJ1aWxkRnJvbU9yZGVyZWRKcyA9IHJlcXVpcmUoJy4vb3JkZXJlZEpzMlhtbCcpO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgYXR0cmlidXRlTmFtZVByZWZpeDogJ0BfJyxcbiAgYXR0cmlidXRlc0dyb3VwTmFtZTogZmFsc2UsXG4gIHRleHROb2RlTmFtZTogJyN0ZXh0JyxcbiAgaWdub3JlQXR0cmlidXRlczogdHJ1ZSxcbiAgY2RhdGFQcm9wTmFtZTogZmFsc2UsXG4gIGZvcm1hdDogZmFsc2UsXG4gIGluZGVudEJ5OiAnICAnLFxuICBzdXBwcmVzc0VtcHR5Tm9kZTogZmFsc2UsXG4gIHN1cHByZXNzVW5wYWlyZWROb2RlOiB0cnVlLFxuICBzdXBwcmVzc0Jvb2xlYW5BdHRyaWJ1dGVzOiB0cnVlLFxuICB0YWdWYWx1ZVByb2Nlc3NvcjogZnVuY3Rpb24oa2V5LCBhKSB7XG4gICAgcmV0dXJuIGE7XG4gIH0sXG4gIGF0dHJpYnV0ZVZhbHVlUHJvY2Vzc29yOiBmdW5jdGlvbihhdHRyTmFtZSwgYSkge1xuICAgIHJldHVybiBhO1xuICB9LFxuICBwcmVzZXJ2ZU9yZGVyOiBmYWxzZSxcbiAgY29tbWVudFByb3BOYW1lOiBmYWxzZSxcbiAgdW5wYWlyZWRUYWdzOiBbXSxcbiAgZW50aXRpZXM6IFtcbiAgICB7IHJlZ2V4OiBuZXcgUmVnRXhwKFwiJlwiLCBcImdcIiksIHZhbDogXCImYW1wO1wiIH0sLy9pdCBtdXN0IGJlIG9uIHRvcFxuICAgIHsgcmVnZXg6IG5ldyBSZWdFeHAoXCI+XCIsIFwiZ1wiKSwgdmFsOiBcIiZndDtcIiB9LFxuICAgIHsgcmVnZXg6IG5ldyBSZWdFeHAoXCI8XCIsIFwiZ1wiKSwgdmFsOiBcIiZsdDtcIiB9LFxuICAgIHsgcmVnZXg6IG5ldyBSZWdFeHAoXCJcXCdcIiwgXCJnXCIpLCB2YWw6IFwiJmFwb3M7XCIgfSxcbiAgICB7IHJlZ2V4OiBuZXcgUmVnRXhwKFwiXFxcIlwiLCBcImdcIiksIHZhbDogXCImcXVvdDtcIiB9XG4gIF0sXG4gIHByb2Nlc3NFbnRpdGllczogdHJ1ZSxcbiAgc3RvcE5vZGVzOiBbXSxcbiAgLy8gdHJhbnNmb3JtVGFnTmFtZTogZmFsc2UsXG4gIC8vIHRyYW5zZm9ybUF0dHJpYnV0ZU5hbWU6IGZhbHNlLFxuICBvbmVMaXN0R3JvdXA6IGZhbHNlXG59O1xuXG5mdW5jdGlvbiBCdWlsZGVyKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZUF0dHJpYnV0ZXMgfHwgdGhpcy5vcHRpb25zLmF0dHJpYnV0ZXNHcm91cE5hbWUpIHtcbiAgICB0aGlzLmlzQXR0cmlidXRlID0gZnVuY3Rpb24oLyphKi8pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYXR0clByZWZpeExlbiA9IHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVOYW1lUHJlZml4Lmxlbmd0aDtcbiAgICB0aGlzLmlzQXR0cmlidXRlID0gaXNBdHRyaWJ1dGU7XG4gIH1cblxuICB0aGlzLnByb2Nlc3NUZXh0T3JPYmpOb2RlID0gcHJvY2Vzc1RleHRPck9iak5vZGVcblxuICBpZiAodGhpcy5vcHRpb25zLmZvcm1hdCkge1xuICAgIHRoaXMuaW5kZW50YXRlID0gaW5kZW50YXRlO1xuICAgIHRoaXMudGFnRW5kQ2hhciA9ICc+XFxuJztcbiAgICB0aGlzLm5ld0xpbmUgPSAnXFxuJztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmluZGVudGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH07XG4gICAgdGhpcy50YWdFbmRDaGFyID0gJz4nO1xuICAgIHRoaXMubmV3TGluZSA9ICcnO1xuICB9XG59XG5cbkJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24oak9iaikge1xuICBpZih0aGlzLm9wdGlvbnMucHJlc2VydmVPcmRlcil7XG4gICAgcmV0dXJuIGJ1aWxkRnJvbU9yZGVyZWRKcyhqT2JqLCB0aGlzLm9wdGlvbnMpO1xuICB9ZWxzZSB7XG4gICAgaWYoQXJyYXkuaXNBcnJheShqT2JqKSAmJiB0aGlzLm9wdGlvbnMuYXJyYXlOb2RlTmFtZSAmJiB0aGlzLm9wdGlvbnMuYXJyYXlOb2RlTmFtZS5sZW5ndGggPiAxKXtcbiAgICAgIGpPYmogPSB7XG4gICAgICAgIFt0aGlzLm9wdGlvbnMuYXJyYXlOb2RlTmFtZV0gOiBqT2JqXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmoyeChqT2JqLCAwKS52YWw7XG4gIH1cbn07XG5cbkJ1aWxkZXIucHJvdG90eXBlLmoyeCA9IGZ1bmN0aW9uKGpPYmosIGxldmVsKSB7XG4gIGxldCBhdHRyU3RyID0gJyc7XG4gIGxldCB2YWwgPSAnJztcbiAgZm9yIChsZXQga2V5IGluIGpPYmopIHtcbiAgICBpZighak9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSBjb250aW51ZTtcbiAgICBpZiAodHlwZW9mIGpPYmpba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIHN1cHJlc3MgdW5kZWZpbmVkIG5vZGUgb25seSBpZiBpdCBpcyBub3QgYW4gYXR0cmlidXRlXG4gICAgICBpZiAodGhpcy5pc0F0dHJpYnV0ZShrZXkpKSB7XG4gICAgICAgIHZhbCArPSAnJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGpPYmpba2V5XSA9PT0gbnVsbCkge1xuICAgICAgLy8gbnVsbCBhdHRyaWJ1dGUgc2hvdWxkIGJlIGlnbm9yZWQgYnkgdGhlIGF0dHJpYnV0ZSBsaXN0LCBidXQgc2hvdWxkIG5vdCBjYXVzZSB0aGUgdGFnIGNsb3NpbmdcbiAgICAgIGlmICh0aGlzLmlzQXR0cmlidXRlKGtleSkpIHtcbiAgICAgICAgdmFsICs9ICcnO1xuICAgICAgfSBlbHNlIGlmIChrZXlbMF0gPT09ICc/Jykge1xuICAgICAgICB2YWwgKz0gdGhpcy5pbmRlbnRhdGUobGV2ZWwpICsgJzwnICsga2V5ICsgJz8nICsgdGhpcy50YWdFbmRDaGFyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsICs9IHRoaXMuaW5kZW50YXRlKGxldmVsKSArICc8JyArIGtleSArICcvJyArIHRoaXMudGFnRW5kQ2hhcjtcbiAgICAgIH1cbiAgICAgIC8vIHZhbCArPSB0aGlzLmluZGVudGF0ZShsZXZlbCkgKyAnPCcgKyBrZXkgKyAnLycgKyB0aGlzLnRhZ0VuZENoYXI7XG4gICAgfSBlbHNlIGlmIChqT2JqW2tleV0gaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICB2YWwgKz0gdGhpcy5idWlsZFRleHRWYWxOb2RlKGpPYmpba2V5XSwga2V5LCAnJywgbGV2ZWwpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGpPYmpba2V5XSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIC8vcHJlbWl0aXZlIHR5cGVcbiAgICAgIGNvbnN0IGF0dHIgPSB0aGlzLmlzQXR0cmlidXRlKGtleSk7XG4gICAgICBpZiAoYXR0cikge1xuICAgICAgICBhdHRyU3RyICs9IHRoaXMuYnVpbGRBdHRyUGFpclN0cihhdHRyLCAnJyArIGpPYmpba2V5XSk7XG4gICAgICB9ZWxzZSB7XG4gICAgICAgIC8vdGFnIHZhbHVlXG4gICAgICAgIGlmIChrZXkgPT09IHRoaXMub3B0aW9ucy50ZXh0Tm9kZU5hbWUpIHtcbiAgICAgICAgICBsZXQgbmV3dmFsID0gdGhpcy5vcHRpb25zLnRhZ1ZhbHVlUHJvY2Vzc29yKGtleSwgJycgKyBqT2JqW2tleV0pO1xuICAgICAgICAgIHZhbCArPSB0aGlzLnJlcGxhY2VFbnRpdGllc1ZhbHVlKG5ld3ZhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsICs9IHRoaXMuYnVpbGRUZXh0VmFsTm9kZShqT2JqW2tleV0sIGtleSwgJycsIGxldmVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShqT2JqW2tleV0pKSB7XG4gICAgICAvL3JlcGVhdGVkIG5vZGVzXG4gICAgICBjb25zdCBhcnJMZW4gPSBqT2JqW2tleV0ubGVuZ3RoO1xuICAgICAgbGV0IGxpc3RUYWdWYWwgPSBcIlwiO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhcnJMZW47IGorKykge1xuICAgICAgICBjb25zdCBpdGVtID0gak9ialtrZXldW2pdO1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gc3VwcmVzcyB1bmRlZmluZWQgbm9kZVxuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgICBpZihrZXlbMF0gPT09IFwiP1wiKSB2YWwgKz0gdGhpcy5pbmRlbnRhdGUobGV2ZWwpICsgJzwnICsga2V5ICsgJz8nICsgdGhpcy50YWdFbmRDaGFyO1xuICAgICAgICAgIGVsc2UgdmFsICs9IHRoaXMuaW5kZW50YXRlKGxldmVsKSArICc8JyArIGtleSArICcvJyArIHRoaXMudGFnRW5kQ2hhcjtcbiAgICAgICAgICAvLyB2YWwgKz0gdGhpcy5pbmRlbnRhdGUobGV2ZWwpICsgJzwnICsga2V5ICsgJy8nICsgdGhpcy50YWdFbmRDaGFyO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5vbmVMaXN0R3JvdXAgKXtcbiAgICAgICAgICAgIGxpc3RUYWdWYWwgKz0gdGhpcy5qMngoaXRlbSwgbGV2ZWwgKyAxKS52YWw7XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBsaXN0VGFnVmFsICs9IHRoaXMucHJvY2Vzc1RleHRPck9iak5vZGUoaXRlbSwga2V5LCBsZXZlbClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGlzdFRhZ1ZhbCArPSB0aGlzLmJ1aWxkVGV4dFZhbE5vZGUoaXRlbSwga2V5LCAnJywgbGV2ZWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZih0aGlzLm9wdGlvbnMub25lTGlzdEdyb3VwKXtcbiAgICAgICAgbGlzdFRhZ1ZhbCA9IHRoaXMuYnVpbGRPYmplY3ROb2RlKGxpc3RUYWdWYWwsIGtleSwgJycsIGxldmVsKTtcbiAgICAgIH1cbiAgICAgIHZhbCArPSBsaXN0VGFnVmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL25lc3RlZCBub2RlXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmF0dHJpYnV0ZXNHcm91cE5hbWUgJiYga2V5ID09PSB0aGlzLm9wdGlvbnMuYXR0cmlidXRlc0dyb3VwTmFtZSkge1xuICAgICAgICBjb25zdCBLcyA9IE9iamVjdC5rZXlzKGpPYmpba2V5XSk7XG4gICAgICAgIGNvbnN0IEwgPSBLcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgTDsgaisrKSB7XG4gICAgICAgICAgYXR0clN0ciArPSB0aGlzLmJ1aWxkQXR0clBhaXJTdHIoS3Nbal0sICcnICsgak9ialtrZXldW0tzW2pdXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCArPSB0aGlzLnByb2Nlc3NUZXh0T3JPYmpOb2RlKGpPYmpba2V5XSwga2V5LCBsZXZlbClcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHthdHRyU3RyOiBhdHRyU3RyLCB2YWw6IHZhbH07XG59O1xuXG5CdWlsZGVyLnByb3RvdHlwZS5idWlsZEF0dHJQYWlyU3RyID0gZnVuY3Rpb24oYXR0ck5hbWUsIHZhbCl7XG4gIHZhbCA9IHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVWYWx1ZVByb2Nlc3NvcihhdHRyTmFtZSwgJycgKyB2YWwpO1xuICB2YWwgPSB0aGlzLnJlcGxhY2VFbnRpdGllc1ZhbHVlKHZhbCk7XG4gIGlmICh0aGlzLm9wdGlvbnMuc3VwcHJlc3NCb29sZWFuQXR0cmlidXRlcyAmJiB2YWwgPT09IFwidHJ1ZVwiKSB7XG4gICAgcmV0dXJuICcgJyArIGF0dHJOYW1lO1xuICB9IGVsc2UgcmV0dXJuICcgJyArIGF0dHJOYW1lICsgJz1cIicgKyB2YWwgKyAnXCInO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzVGV4dE9yT2JqTm9kZSAob2JqZWN0LCBrZXksIGxldmVsKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHRoaXMuajJ4KG9iamVjdCwgbGV2ZWwgKyAxKTtcbiAgaWYgKG9iamVjdFt0aGlzLm9wdGlvbnMudGV4dE5vZGVOYW1lXSAhPT0gdW5kZWZpbmVkICYmIE9iamVjdC5rZXlzKG9iamVjdCkubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVpbGRUZXh0VmFsTm9kZShvYmplY3RbdGhpcy5vcHRpb25zLnRleHROb2RlTmFtZV0sIGtleSwgcmVzdWx0LmF0dHJTdHIsIGxldmVsKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5idWlsZE9iamVjdE5vZGUocmVzdWx0LnZhbCwga2V5LCByZXN1bHQuYXR0clN0ciwgbGV2ZWwpO1xuICB9XG59XG5cbkJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkT2JqZWN0Tm9kZSA9IGZ1bmN0aW9uKHZhbCwga2V5LCBhdHRyU3RyLCBsZXZlbCkge1xuICBpZih2YWwgPT09IFwiXCIpe1xuICAgIGlmKGtleVswXSA9PT0gXCI/XCIpIHJldHVybiAgdGhpcy5pbmRlbnRhdGUobGV2ZWwpICsgJzwnICsga2V5ICsgYXR0clN0cisgJz8nICsgdGhpcy50YWdFbmRDaGFyO1xuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZW50YXRlKGxldmVsKSArICc8JyArIGtleSArIGF0dHJTdHIgKyB0aGlzLmNsb3NlVGFnKGtleSkgKyB0aGlzLnRhZ0VuZENoYXI7XG4gICAgfVxuICB9ZWxzZXtcblxuICAgIGxldCB0YWdFbmRFeHAgPSAnPC8nICsga2V5ICsgdGhpcy50YWdFbmRDaGFyO1xuICAgIGxldCBwaUNsb3NpbmdDaGFyID0gXCJcIjtcbiAgICBcbiAgICBpZihrZXlbMF0gPT09IFwiP1wiKSB7XG4gICAgICBwaUNsb3NpbmdDaGFyID0gXCI/XCI7XG4gICAgICB0YWdFbmRFeHAgPSBcIlwiO1xuICAgIH1cbiAgXG4gICAgLy8gYXR0clN0ciBpcyBhbiBlbXB0eSBzdHJpbmcgaW4gY2FzZSB0aGUgYXR0cmlidXRlIGNhbWUgYXMgdW5kZWZpbmVkIG9yIG51bGxcbiAgICBpZiAoKGF0dHJTdHIgfHwgYXR0clN0ciA9PT0gJycpICYmIHZhbC5pbmRleE9mKCc8JykgPT09IC0xKSB7XG4gICAgICByZXR1cm4gKCB0aGlzLmluZGVudGF0ZShsZXZlbCkgKyAnPCcgKyAga2V5ICsgYXR0clN0ciArIHBpQ2xvc2luZ0NoYXIgKyAnPicgKyB2YWwgKyB0YWdFbmRFeHAgKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5jb21tZW50UHJvcE5hbWUgIT09IGZhbHNlICYmIGtleSA9PT0gdGhpcy5vcHRpb25zLmNvbW1lbnRQcm9wTmFtZSAmJiBwaUNsb3NpbmdDaGFyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZW50YXRlKGxldmVsKSArIGA8IS0tJHt2YWx9LS0+YCArIHRoaXMubmV3TGluZTtcbiAgICB9ZWxzZSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLmluZGVudGF0ZShsZXZlbCkgKyAnPCcgKyBrZXkgKyBhdHRyU3RyICsgcGlDbG9zaW5nQ2hhciArIHRoaXMudGFnRW5kQ2hhciArXG4gICAgICAgIHZhbCArXG4gICAgICAgIHRoaXMuaW5kZW50YXRlKGxldmVsKSArIHRhZ0VuZEV4cCAgICApO1xuICAgIH1cbiAgfVxufVxuXG5CdWlsZGVyLnByb3RvdHlwZS5jbG9zZVRhZyA9IGZ1bmN0aW9uKGtleSl7XG4gIGxldCBjbG9zZVRhZyA9IFwiXCI7XG4gIGlmKHRoaXMub3B0aW9ucy51bnBhaXJlZFRhZ3MuaW5kZXhPZihrZXkpICE9PSAtMSl7IC8vdW5wYWlyZWRcbiAgICBpZighdGhpcy5vcHRpb25zLnN1cHByZXNzVW5wYWlyZWROb2RlKSBjbG9zZVRhZyA9IFwiL1wiXG4gIH1lbHNlIGlmKHRoaXMub3B0aW9ucy5zdXBwcmVzc0VtcHR5Tm9kZSl7IC8vZW1wdHlcbiAgICBjbG9zZVRhZyA9IFwiL1wiO1xuICB9ZWxzZXtcbiAgICBjbG9zZVRhZyA9IGA+PC8ke2tleX1gXG4gIH1cbiAgcmV0dXJuIGNsb3NlVGFnO1xufVxuXG5mdW5jdGlvbiBidWlsZEVtcHR5T2JqTm9kZSh2YWwsIGtleSwgYXR0clN0ciwgbGV2ZWwpIHtcbiAgaWYgKHZhbCAhPT0gJycpIHtcbiAgICByZXR1cm4gdGhpcy5idWlsZE9iamVjdE5vZGUodmFsLCBrZXksIGF0dHJTdHIsIGxldmVsKTtcbiAgfSBlbHNlIHtcbiAgICBpZihrZXlbMF0gPT09IFwiP1wiKSByZXR1cm4gIHRoaXMuaW5kZW50YXRlKGxldmVsKSArICc8JyArIGtleSArIGF0dHJTdHIrICc/JyArIHRoaXMudGFnRW5kQ2hhcjtcbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiAgdGhpcy5pbmRlbnRhdGUobGV2ZWwpICsgJzwnICsga2V5ICsgYXR0clN0ciArICcvJyArIHRoaXMudGFnRW5kQ2hhcjtcbiAgICAgIC8vIHJldHVybiB0aGlzLmJ1aWxkVGFnU3RyKGxldmVsLGtleSwgYXR0clN0cik7XG4gICAgfVxuICB9XG59XG5cbkJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkVGV4dFZhbE5vZGUgPSBmdW5jdGlvbih2YWwsIGtleSwgYXR0clN0ciwgbGV2ZWwpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5jZGF0YVByb3BOYW1lICE9PSBmYWxzZSAmJiBrZXkgPT09IHRoaXMub3B0aW9ucy5jZGF0YVByb3BOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZW50YXRlKGxldmVsKSArIGA8IVtDREFUQVske3ZhbH1dXT5gICsgIHRoaXMubmV3TGluZTtcbiAgfWVsc2UgaWYgKHRoaXMub3B0aW9ucy5jb21tZW50UHJvcE5hbWUgIT09IGZhbHNlICYmIGtleSA9PT0gdGhpcy5vcHRpb25zLmNvbW1lbnRQcm9wTmFtZSkge1xuICAgIHJldHVybiB0aGlzLmluZGVudGF0ZShsZXZlbCkgKyBgPCEtLSR7dmFsfS0tPmAgKyAgdGhpcy5uZXdMaW5lO1xuICB9ZWxzZSBpZihrZXlbMF0gPT09IFwiP1wiKSB7Ly9QSSB0YWdcbiAgICByZXR1cm4gIHRoaXMuaW5kZW50YXRlKGxldmVsKSArICc8JyArIGtleSArIGF0dHJTdHIrICc/JyArIHRoaXMudGFnRW5kQ2hhcjsgXG4gIH1lbHNle1xuICAgIGxldCB0ZXh0VmFsdWUgPSB0aGlzLm9wdGlvbnMudGFnVmFsdWVQcm9jZXNzb3Ioa2V5LCB2YWwpO1xuICAgIHRleHRWYWx1ZSA9IHRoaXMucmVwbGFjZUVudGl0aWVzVmFsdWUodGV4dFZhbHVlKTtcbiAgXG4gICAgaWYoIHRleHRWYWx1ZSA9PT0gJycpe1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZW50YXRlKGxldmVsKSArICc8JyArIGtleSArIGF0dHJTdHIgKyB0aGlzLmNsb3NlVGFnKGtleSkgKyB0aGlzLnRhZ0VuZENoYXI7XG4gICAgfWVsc2V7XG4gICAgICByZXR1cm4gdGhpcy5pbmRlbnRhdGUobGV2ZWwpICsgJzwnICsga2V5ICsgYXR0clN0ciArICc+JyArXG4gICAgICAgICB0ZXh0VmFsdWUgK1xuICAgICAgICAnPC8nICsga2V5ICsgdGhpcy50YWdFbmRDaGFyO1xuICAgIH1cbiAgfVxufVxuXG5CdWlsZGVyLnByb3RvdHlwZS5yZXBsYWNlRW50aXRpZXNWYWx1ZSA9IGZ1bmN0aW9uKHRleHRWYWx1ZSl7XG4gIGlmKHRleHRWYWx1ZSAmJiB0ZXh0VmFsdWUubGVuZ3RoID4gMCAmJiB0aGlzLm9wdGlvbnMucHJvY2Vzc0VudGl0aWVzKXtcbiAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5vcHRpb25zLmVudGl0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLm9wdGlvbnMuZW50aXRpZXNbaV07XG4gICAgICB0ZXh0VmFsdWUgPSB0ZXh0VmFsdWUucmVwbGFjZShlbnRpdHkucmVnZXgsIGVudGl0eS52YWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGV4dFZhbHVlO1xufVxuXG5mdW5jdGlvbiBpbmRlbnRhdGUobGV2ZWwpIHtcbiAgcmV0dXJuIHRoaXMub3B0aW9ucy5pbmRlbnRCeS5yZXBlYXQobGV2ZWwpO1xufVxuXG5mdW5jdGlvbiBpc0F0dHJpYnV0ZShuYW1lIC8qLCBvcHRpb25zKi8pIHtcbiAgaWYgKG5hbWUuc3RhcnRzV2l0aCh0aGlzLm9wdGlvbnMuYXR0cmlidXRlTmFtZVByZWZpeCkgJiYgbmFtZSAhPT0gdGhpcy5vcHRpb25zLnRleHROb2RlTmFtZSkge1xuICAgIHJldHVybiBuYW1lLnN1YnN0cih0aGlzLmF0dHJQcmVmaXhMZW4pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1aWxkZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js":
/*!**********************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("const EOL = \"\\n\";\n\n/**\n * \n * @param {array} jArray \n * @param {any} options \n * @returns \n */\nfunction toXml(jArray, options) {\n    let indentation = \"\";\n    if (options.format && options.indentBy.length > 0) {\n        indentation = EOL;\n    }\n    return arrToStr(jArray, options, \"\", indentation);\n}\n\nfunction arrToStr(arr, options, jPath, indentation) {\n    let xmlStr = \"\";\n    let isPreviousElementTag = false;\n\n    for (let i = 0; i < arr.length; i++) {\n        const tagObj = arr[i];\n        const tagName = propName(tagObj);\n        if(tagName === undefined) continue;\n\n        let newJPath = \"\";\n        if (jPath.length === 0) newJPath = tagName\n        else newJPath = `${jPath}.${tagName}`;\n\n        if (tagName === options.textNodeName) {\n            let tagText = tagObj[tagName];\n            if (!isStopNode(newJPath, options)) {\n                tagText = options.tagValueProcessor(tagName, tagText);\n                tagText = replaceEntitiesValue(tagText, options);\n            }\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += tagText;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.cdataPropName) {\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.commentPropName) {\n            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\n            isPreviousElementTag = true;\n            continue;\n        } else if (tagName[0] === \"?\") {\n            const attStr = attr_to_str(tagObj[\":@\"], options);\n            const tempInd = tagName === \"?xml\" ? \"\" : indentation;\n            let piTextNodeName = tagObj[tagName][0][options.textNodeName];\n            piTextNodeName = piTextNodeName.length !== 0 ? \" \" + piTextNodeName : \"\"; //remove extra spacing\n            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;\n            isPreviousElementTag = true;\n            continue;\n        }\n        let newIdentation = indentation;\n        if (newIdentation !== \"\") {\n            newIdentation += options.indentBy;\n        }\n        const attStr = attr_to_str(tagObj[\":@\"], options);\n        const tagStart = indentation + `<${tagName}${attStr}`;\n        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);\n        if (options.unpairedTags.indexOf(tagName) !== -1) {\n            if (options.suppressUnpairedNode) xmlStr += tagStart + \">\";\n            else xmlStr += tagStart + \"/>\";\n        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {\n            xmlStr += tagStart + \"/>\";\n        } else if (tagValue && tagValue.endsWith(\">\")) {\n            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;\n        } else {\n            xmlStr += tagStart + \">\";\n            if (tagValue && indentation !== \"\" && (tagValue.includes(\"/>\") || tagValue.includes(\"</\"))) {\n                xmlStr += indentation + options.indentBy + tagValue + indentation;\n            } else {\n                xmlStr += tagValue;\n            }\n            xmlStr += `</${tagName}>`;\n        }\n        isPreviousElementTag = true;\n    }\n\n    return xmlStr;\n}\n\nfunction propName(obj) {\n    const keys = Object.keys(obj);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if(!obj.hasOwnProperty(key)) continue;\n        if (key !== \":@\") return key;\n    }\n}\n\nfunction attr_to_str(attrMap, options) {\n    let attrStr = \"\";\n    if (attrMap && !options.ignoreAttributes) {\n        for (let attr in attrMap) {\n            if(!attrMap.hasOwnProperty(attr)) continue;\n            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n            attrVal = replaceEntitiesValue(attrVal, options);\n            if (attrVal === true && options.suppressBooleanAttributes) {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;\n            } else {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}=\"${attrVal}\"`;\n            }\n        }\n    }\n    return attrStr;\n}\n\nfunction isStopNode(jPath, options) {\n    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);\n    let tagName = jPath.substr(jPath.lastIndexOf(\".\") + 1);\n    for (let index in options.stopNodes) {\n        if (options.stopNodes[index] === jPath || options.stopNodes[index] === \"*.\" + tagName) return true;\n    }\n    return false;\n}\n\nfunction replaceEntitiesValue(textValue, options) {\n    if (textValue && textValue.length > 0 && options.processEntities) {\n        for (let i = 0; i < options.entities.length; i++) {\n            const entity = options.entities[i];\n            textValue = textValue.replace(entity.regex, entity.val);\n        }\n    }\n    return textValue;\n}\nmodule.exports = toXml;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxidWlsZGVyL29yZGVyZWRKczJYbWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLE1BQU0sR0FBRyxRQUFROztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHlDQUF5QztBQUMzRTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDJDQUEyQyx5Q0FBeUM7QUFDcEY7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEYsb0NBQW9DLFFBQVEsRUFBRSxlQUFlLEVBQUUsT0FBTztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVEsRUFBRSxPQUFPO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWLHFDQUFxQyxTQUFTLEVBQUUsWUFBWSxJQUFJLFFBQVE7QUFDeEUsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdEQUFnRDtBQUMvRSxjQUFjO0FBQ2QsK0JBQStCLGdEQUFnRCxJQUFJLFFBQVE7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsNkJBQTZCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGlhcnktZnJvbnQtZW5kLy4vbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMveG1sYnVpbGRlci9vcmRlcmVkSnMyWG1sLmpzPzBjMmMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgRU9MID0gXCJcXG5cIjtcblxuLyoqXG4gKiBcbiAqIEBwYXJhbSB7YXJyYXl9IGpBcnJheSBcbiAqIEBwYXJhbSB7YW55fSBvcHRpb25zIFxuICogQHJldHVybnMgXG4gKi9cbmZ1bmN0aW9uIHRvWG1sKGpBcnJheSwgb3B0aW9ucykge1xuICAgIGxldCBpbmRlbnRhdGlvbiA9IFwiXCI7XG4gICAgaWYgKG9wdGlvbnMuZm9ybWF0ICYmIG9wdGlvbnMuaW5kZW50QnkubGVuZ3RoID4gMCkge1xuICAgICAgICBpbmRlbnRhdGlvbiA9IEVPTDtcbiAgICB9XG4gICAgcmV0dXJuIGFyclRvU3RyKGpBcnJheSwgb3B0aW9ucywgXCJcIiwgaW5kZW50YXRpb24pO1xufVxuXG5mdW5jdGlvbiBhcnJUb1N0cihhcnIsIG9wdGlvbnMsIGpQYXRoLCBpbmRlbnRhdGlvbikge1xuICAgIGxldCB4bWxTdHIgPSBcIlwiO1xuICAgIGxldCBpc1ByZXZpb3VzRWxlbWVudFRhZyA9IGZhbHNlO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdGFnT2JqID0gYXJyW2ldO1xuICAgICAgICBjb25zdCB0YWdOYW1lID0gcHJvcE5hbWUodGFnT2JqKTtcbiAgICAgICAgaWYodGFnTmFtZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcblxuICAgICAgICBsZXQgbmV3SlBhdGggPSBcIlwiO1xuICAgICAgICBpZiAoalBhdGgubGVuZ3RoID09PSAwKSBuZXdKUGF0aCA9IHRhZ05hbWVcbiAgICAgICAgZWxzZSBuZXdKUGF0aCA9IGAke2pQYXRofS4ke3RhZ05hbWV9YDtcblxuICAgICAgICBpZiAodGFnTmFtZSA9PT0gb3B0aW9ucy50ZXh0Tm9kZU5hbWUpIHtcbiAgICAgICAgICAgIGxldCB0YWdUZXh0ID0gdGFnT2JqW3RhZ05hbWVdO1xuICAgICAgICAgICAgaWYgKCFpc1N0b3BOb2RlKG5ld0pQYXRoLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIHRhZ1RleHQgPSBvcHRpb25zLnRhZ1ZhbHVlUHJvY2Vzc29yKHRhZ05hbWUsIHRhZ1RleHQpO1xuICAgICAgICAgICAgICAgIHRhZ1RleHQgPSByZXBsYWNlRW50aXRpZXNWYWx1ZSh0YWdUZXh0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1ByZXZpb3VzRWxlbWVudFRhZykge1xuICAgICAgICAgICAgICAgIHhtbFN0ciArPSBpbmRlbnRhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhtbFN0ciArPSB0YWdUZXh0O1xuICAgICAgICAgICAgaXNQcmV2aW91c0VsZW1lbnRUYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRhZ05hbWUgPT09IG9wdGlvbnMuY2RhdGFQcm9wTmFtZSkge1xuICAgICAgICAgICAgaWYgKGlzUHJldmlvdXNFbGVtZW50VGFnKSB7XG4gICAgICAgICAgICAgICAgeG1sU3RyICs9IGluZGVudGF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeG1sU3RyICs9IGA8IVtDREFUQVske3RhZ09ialt0YWdOYW1lXVswXVtvcHRpb25zLnRleHROb2RlTmFtZV19XV0+YDtcbiAgICAgICAgICAgIGlzUHJldmlvdXNFbGVtZW50VGFnID0gZmFsc2U7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWdOYW1lID09PSBvcHRpb25zLmNvbW1lbnRQcm9wTmFtZSkge1xuICAgICAgICAgICAgeG1sU3RyICs9IGluZGVudGF0aW9uICsgYDwhLS0ke3RhZ09ialt0YWdOYW1lXVswXVtvcHRpb25zLnRleHROb2RlTmFtZV19LS0+YDtcbiAgICAgICAgICAgIGlzUHJldmlvdXNFbGVtZW50VGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRhZ05hbWVbMF0gPT09IFwiP1wiKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRTdHIgPSBhdHRyX3RvX3N0cih0YWdPYmpbXCI6QFwiXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCB0ZW1wSW5kID0gdGFnTmFtZSA9PT0gXCI/eG1sXCIgPyBcIlwiIDogaW5kZW50YXRpb247XG4gICAgICAgICAgICBsZXQgcGlUZXh0Tm9kZU5hbWUgPSB0YWdPYmpbdGFnTmFtZV1bMF1bb3B0aW9ucy50ZXh0Tm9kZU5hbWVdO1xuICAgICAgICAgICAgcGlUZXh0Tm9kZU5hbWUgPSBwaVRleHROb2RlTmFtZS5sZW5ndGggIT09IDAgPyBcIiBcIiArIHBpVGV4dE5vZGVOYW1lIDogXCJcIjsgLy9yZW1vdmUgZXh0cmEgc3BhY2luZ1xuICAgICAgICAgICAgeG1sU3RyICs9IHRlbXBJbmQgKyBgPCR7dGFnTmFtZX0ke3BpVGV4dE5vZGVOYW1lfSR7YXR0U3RyfT8+YDtcbiAgICAgICAgICAgIGlzUHJldmlvdXNFbGVtZW50VGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXdJZGVudGF0aW9uID0gaW5kZW50YXRpb247XG4gICAgICAgIGlmIChuZXdJZGVudGF0aW9uICE9PSBcIlwiKSB7XG4gICAgICAgICAgICBuZXdJZGVudGF0aW9uICs9IG9wdGlvbnMuaW5kZW50Qnk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXR0U3RyID0gYXR0cl90b19zdHIodGFnT2JqW1wiOkBcIl0sIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB0YWdTdGFydCA9IGluZGVudGF0aW9uICsgYDwke3RhZ05hbWV9JHthdHRTdHJ9YDtcbiAgICAgICAgY29uc3QgdGFnVmFsdWUgPSBhcnJUb1N0cih0YWdPYmpbdGFnTmFtZV0sIG9wdGlvbnMsIG5ld0pQYXRoLCBuZXdJZGVudGF0aW9uKTtcbiAgICAgICAgaWYgKG9wdGlvbnMudW5wYWlyZWRUYWdzLmluZGV4T2YodGFnTmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdXBwcmVzc1VucGFpcmVkTm9kZSkgeG1sU3RyICs9IHRhZ1N0YXJ0ICsgXCI+XCI7XG4gICAgICAgICAgICBlbHNlIHhtbFN0ciArPSB0YWdTdGFydCArIFwiLz5cIjtcbiAgICAgICAgfSBlbHNlIGlmICgoIXRhZ1ZhbHVlIHx8IHRhZ1ZhbHVlLmxlbmd0aCA9PT0gMCkgJiYgb3B0aW9ucy5zdXBwcmVzc0VtcHR5Tm9kZSkge1xuICAgICAgICAgICAgeG1sU3RyICs9IHRhZ1N0YXJ0ICsgXCIvPlwiO1xuICAgICAgICB9IGVsc2UgaWYgKHRhZ1ZhbHVlICYmIHRhZ1ZhbHVlLmVuZHNXaXRoKFwiPlwiKSkge1xuICAgICAgICAgICAgeG1sU3RyICs9IHRhZ1N0YXJ0ICsgYD4ke3RhZ1ZhbHVlfSR7aW5kZW50YXRpb259PC8ke3RhZ05hbWV9PmA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4bWxTdHIgKz0gdGFnU3RhcnQgKyBcIj5cIjtcbiAgICAgICAgICAgIGlmICh0YWdWYWx1ZSAmJiBpbmRlbnRhdGlvbiAhPT0gXCJcIiAmJiAodGFnVmFsdWUuaW5jbHVkZXMoXCIvPlwiKSB8fCB0YWdWYWx1ZS5pbmNsdWRlcyhcIjwvXCIpKSkge1xuICAgICAgICAgICAgICAgIHhtbFN0ciArPSBpbmRlbnRhdGlvbiArIG9wdGlvbnMuaW5kZW50QnkgKyB0YWdWYWx1ZSArIGluZGVudGF0aW9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4bWxTdHIgKz0gdGFnVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4bWxTdHIgKz0gYDwvJHt0YWdOYW1lfT5gO1xuICAgICAgICB9XG4gICAgICAgIGlzUHJldmlvdXNFbGVtZW50VGFnID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4geG1sU3RyO1xufVxuXG5mdW5jdGlvbiBwcm9wTmFtZShvYmopIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYoIW9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSBjb250aW51ZTtcbiAgICAgICAgaWYgKGtleSAhPT0gXCI6QFwiKSByZXR1cm4ga2V5O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYXR0cl90b19zdHIoYXR0ck1hcCwgb3B0aW9ucykge1xuICAgIGxldCBhdHRyU3RyID0gXCJcIjtcbiAgICBpZiAoYXR0ck1hcCAmJiAhb3B0aW9ucy5pZ25vcmVBdHRyaWJ1dGVzKSB7XG4gICAgICAgIGZvciAobGV0IGF0dHIgaW4gYXR0ck1hcCkge1xuICAgICAgICAgICAgaWYoIWF0dHJNYXAuaGFzT3duUHJvcGVydHkoYXR0cikpIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IGF0dHJWYWwgPSBvcHRpb25zLmF0dHJpYnV0ZVZhbHVlUHJvY2Vzc29yKGF0dHIsIGF0dHJNYXBbYXR0cl0pO1xuICAgICAgICAgICAgYXR0clZhbCA9IHJlcGxhY2VFbnRpdGllc1ZhbHVlKGF0dHJWYWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGF0dHJWYWwgPT09IHRydWUgJiYgb3B0aW9ucy5zdXBwcmVzc0Jvb2xlYW5BdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgYXR0clN0ciArPSBgICR7YXR0ci5zdWJzdHIob3B0aW9ucy5hdHRyaWJ1dGVOYW1lUHJlZml4Lmxlbmd0aCl9YDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXR0clN0ciArPSBgICR7YXR0ci5zdWJzdHIob3B0aW9ucy5hdHRyaWJ1dGVOYW1lUHJlZml4Lmxlbmd0aCl9PVwiJHthdHRyVmFsfVwiYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXR0clN0cjtcbn1cblxuZnVuY3Rpb24gaXNTdG9wTm9kZShqUGF0aCwgb3B0aW9ucykge1xuICAgIGpQYXRoID0galBhdGguc3Vic3RyKDAsIGpQYXRoLmxlbmd0aCAtIG9wdGlvbnMudGV4dE5vZGVOYW1lLmxlbmd0aCAtIDEpO1xuICAgIGxldCB0YWdOYW1lID0galBhdGguc3Vic3RyKGpQYXRoLmxhc3RJbmRleE9mKFwiLlwiKSArIDEpO1xuICAgIGZvciAobGV0IGluZGV4IGluIG9wdGlvbnMuc3RvcE5vZGVzKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnN0b3BOb2Rlc1tpbmRleF0gPT09IGpQYXRoIHx8IG9wdGlvbnMuc3RvcE5vZGVzW2luZGV4XSA9PT0gXCIqLlwiICsgdGFnTmFtZSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZUVudGl0aWVzVmFsdWUodGV4dFZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKHRleHRWYWx1ZSAmJiB0ZXh0VmFsdWUubGVuZ3RoID4gMCAmJiBvcHRpb25zLnByb2Nlc3NFbnRpdGllcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMuZW50aXRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVudGl0eSA9IG9wdGlvbnMuZW50aXRpZXNbaV07XG4gICAgICAgICAgICB0ZXh0VmFsdWUgPSB0ZXh0VmFsdWUucmVwbGFjZShlbnRpdHkucmVnZXgsIGVudGl0eS52YWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZXh0VmFsdWU7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHRvWG1sO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js":
/*!*********************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/fast-xml-parser/src/util.js\");\n\n//TODO: handle comments\nfunction readDocType(xmlData, i){\n    \n    const entities = {};\n    if( xmlData[i + 3] === 'O' &&\n         xmlData[i + 4] === 'C' &&\n         xmlData[i + 5] === 'T' &&\n         xmlData[i + 6] === 'Y' &&\n         xmlData[i + 7] === 'P' &&\n         xmlData[i + 8] === 'E')\n    {    \n        i = i+9;\n        let angleBracketsCount = 1;\n        let hasBody = false, comment = false;\n        let exp = \"\";\n        for(;i<xmlData.length;i++){\n            if (xmlData[i] === '<' && !comment) { //Determine the tag type\n                if( hasBody && isEntity(xmlData, i)){\n                    i += 7; \n                    [entityName, val,i] = readEntityExp(xmlData,i+1);\n                    if(val.indexOf(\"&\") === -1) //Parameter entities are not supported\n                        entities[ validateEntityName(entityName) ] = {\n                            regx : RegExp( `&${entityName};`,\"g\"),\n                            val: val\n                        };\n                }\n                else if( hasBody && isElement(xmlData, i))  i += 8;//Not supported\n                else if( hasBody && isAttlist(xmlData, i))  i += 8;//Not supported\n                else if( hasBody && isNotation(xmlData, i)) i += 9;//Not supported\n                else if( isComment)                         comment = true;\n                else                                        throw new Error(\"Invalid DOCTYPE\");\n\n                angleBracketsCount++;\n                exp = \"\";\n            } else if (xmlData[i] === '>') { //Read tag content\n                if(comment){\n                    if( xmlData[i - 1] === \"-\" && xmlData[i - 2] === \"-\"){\n                        comment = false;\n                        angleBracketsCount--;\n                    }\n                }else{\n                    angleBracketsCount--;\n                }\n                if (angleBracketsCount === 0) {\n                  break;\n                }\n            }else if( xmlData[i] === '['){\n                hasBody = true;\n            }else{\n                exp += xmlData[i];\n            }\n        }\n        if(angleBracketsCount !== 0){\n            throw new Error(`Unclosed DOCTYPE`);\n        }\n    }else{\n        throw new Error(`Invalid Tag instead of DOCTYPE`);\n    }\n    return {entities, i};\n}\n\nfunction readEntityExp(xmlData,i){\n    //External entities are not supported\n    //    <!ENTITY ext SYSTEM \"http://normal-website.com\" >\n\n    //Parameter entities are not supported\n    //    <!ENTITY entityname \"&anotherElement;\">\n\n    //Internal entities are supported\n    //    <!ENTITY entityname \"replacement text\">\n    \n    //read EntityName\n    let entityName = \"\";\n    for (; i < xmlData.length && (xmlData[i] !== \"'\" && xmlData[i] !== '\"' ); i++) {\n        // if(xmlData[i] === \" \") continue;\n        // else \n        entityName += xmlData[i];\n    }\n    entityName = entityName.trim();\n    if(entityName.indexOf(\" \") !== -1) throw new Error(\"External entites are not supported\");\n\n    //read Entity Value\n    const startChar = xmlData[i++];\n    let val = \"\"\n    for (; i < xmlData.length && xmlData[i] !== startChar ; i++) {\n        val += xmlData[i];\n    }\n    return [entityName, val, i];\n}\n\nfunction isComment(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === '-' &&\n    xmlData[i+3] === '-') return true\n    return false\n}\nfunction isEntity(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'E' &&\n    xmlData[i+3] === 'N' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'I' &&\n    xmlData[i+6] === 'T' &&\n    xmlData[i+7] === 'Y') return true\n    return false\n}\nfunction isElement(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'E' &&\n    xmlData[i+3] === 'L' &&\n    xmlData[i+4] === 'E' &&\n    xmlData[i+5] === 'M' &&\n    xmlData[i+6] === 'E' &&\n    xmlData[i+7] === 'N' &&\n    xmlData[i+8] === 'T') return true\n    return false\n}\n\nfunction isAttlist(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'A' &&\n    xmlData[i+3] === 'T' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'L' &&\n    xmlData[i+6] === 'I' &&\n    xmlData[i+7] === 'S' &&\n    xmlData[i+8] === 'T') return true\n    return false\n}\nfunction isNotation(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'N' &&\n    xmlData[i+3] === 'O' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'A' &&\n    xmlData[i+6] === 'T' &&\n    xmlData[i+7] === 'I' &&\n    xmlData[i+8] === 'O' &&\n    xmlData[i+9] === 'N') return true\n    return false\n}\n\nfunction validateEntityName(name){\n    if (util.isName(name))\n\treturn name;\n    else\n        throw new Error(`Invalid entity name ${name}`);\n}\n\nmodule.exports = readDocType;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvRG9jVHlwZVJlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsaUVBQVM7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FLG1FQUFtRTtBQUNuRSxtRUFBbUU7QUFDbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYywrQkFBK0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUVBQW1FO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlEQUFpRDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxLQUFLO0FBQ3BEOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGlhcnktZnJvbnQtZW5kLy4vbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMveG1scGFyc2VyL0RvY1R5cGVSZWFkZXIuanM/ZjRjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG4vL1RPRE86IGhhbmRsZSBjb21tZW50c1xuZnVuY3Rpb24gcmVhZERvY1R5cGUoeG1sRGF0YSwgaSl7XG4gICAgXG4gICAgY29uc3QgZW50aXRpZXMgPSB7fTtcbiAgICBpZiggeG1sRGF0YVtpICsgM10gPT09ICdPJyAmJlxuICAgICAgICAgeG1sRGF0YVtpICsgNF0gPT09ICdDJyAmJlxuICAgICAgICAgeG1sRGF0YVtpICsgNV0gPT09ICdUJyAmJlxuICAgICAgICAgeG1sRGF0YVtpICsgNl0gPT09ICdZJyAmJlxuICAgICAgICAgeG1sRGF0YVtpICsgN10gPT09ICdQJyAmJlxuICAgICAgICAgeG1sRGF0YVtpICsgOF0gPT09ICdFJylcbiAgICB7ICAgIFxuICAgICAgICBpID0gaSs5O1xuICAgICAgICBsZXQgYW5nbGVCcmFja2V0c0NvdW50ID0gMTtcbiAgICAgICAgbGV0IGhhc0JvZHkgPSBmYWxzZSwgY29tbWVudCA9IGZhbHNlO1xuICAgICAgICBsZXQgZXhwID0gXCJcIjtcbiAgICAgICAgZm9yKDtpPHhtbERhdGEubGVuZ3RoO2krKyl7XG4gICAgICAgICAgICBpZiAoeG1sRGF0YVtpXSA9PT0gJzwnICYmICFjb21tZW50KSB7IC8vRGV0ZXJtaW5lIHRoZSB0YWcgdHlwZVxuICAgICAgICAgICAgICAgIGlmKCBoYXNCb2R5ICYmIGlzRW50aXR5KHhtbERhdGEsIGkpKXtcbiAgICAgICAgICAgICAgICAgICAgaSArPSA3OyBcbiAgICAgICAgICAgICAgICAgICAgW2VudGl0eU5hbWUsIHZhbCxpXSA9IHJlYWRFbnRpdHlFeHAoeG1sRGF0YSxpKzEpO1xuICAgICAgICAgICAgICAgICAgICBpZih2YWwuaW5kZXhPZihcIiZcIikgPT09IC0xKSAvL1BhcmFtZXRlciBlbnRpdGllcyBhcmUgbm90IHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgZW50aXRpZXNbIHZhbGlkYXRlRW50aXR5TmFtZShlbnRpdHlOYW1lKSBdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ3ggOiBSZWdFeHAoIGAmJHtlbnRpdHlOYW1lfTtgLFwiZ1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWw6IHZhbFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiggaGFzQm9keSAmJiBpc0VsZW1lbnQoeG1sRGF0YSwgaSkpICBpICs9IDg7Ly9Ob3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICAgICAgZWxzZSBpZiggaGFzQm9keSAmJiBpc0F0dGxpc3QoeG1sRGF0YSwgaSkpICBpICs9IDg7Ly9Ob3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICAgICAgZWxzZSBpZiggaGFzQm9keSAmJiBpc05vdGF0aW9uKHhtbERhdGEsIGkpKSBpICs9IDk7Ly9Ob3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICAgICAgZWxzZSBpZiggaXNDb21tZW50KSAgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlbHNlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgRE9DVFlQRVwiKTtcblxuICAgICAgICAgICAgICAgIGFuZ2xlQnJhY2tldHNDb3VudCsrO1xuICAgICAgICAgICAgICAgIGV4cCA9IFwiXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHhtbERhdGFbaV0gPT09ICc+JykgeyAvL1JlYWQgdGFnIGNvbnRlbnRcbiAgICAgICAgICAgICAgICBpZihjb21tZW50KXtcbiAgICAgICAgICAgICAgICAgICAgaWYoIHhtbERhdGFbaSAtIDFdID09PSBcIi1cIiAmJiB4bWxEYXRhW2kgLSAyXSA9PT0gXCItXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5nbGVCcmFja2V0c0NvdW50LS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgYW5nbGVCcmFja2V0c0NvdW50LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhbmdsZUJyYWNrZXRzQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1lbHNlIGlmKCB4bWxEYXRhW2ldID09PSAnWycpe1xuICAgICAgICAgICAgICAgIGhhc0JvZHkgPSB0cnVlO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgZXhwICs9IHhtbERhdGFbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoYW5nbGVCcmFja2V0c0NvdW50ICE9PSAwKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5jbG9zZWQgRE9DVFlQRWApO1xuICAgICAgICB9XG4gICAgfWVsc2V7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBUYWcgaW5zdGVhZCBvZiBET0NUWVBFYCk7XG4gICAgfVxuICAgIHJldHVybiB7ZW50aXRpZXMsIGl9O1xufVxuXG5mdW5jdGlvbiByZWFkRW50aXR5RXhwKHhtbERhdGEsaSl7XG4gICAgLy9FeHRlcm5hbCBlbnRpdGllcyBhcmUgbm90IHN1cHBvcnRlZFxuICAgIC8vICAgIDwhRU5USVRZIGV4dCBTWVNURU0gXCJodHRwOi8vbm9ybWFsLXdlYnNpdGUuY29tXCIgPlxuXG4gICAgLy9QYXJhbWV0ZXIgZW50aXRpZXMgYXJlIG5vdCBzdXBwb3J0ZWRcbiAgICAvLyAgICA8IUVOVElUWSBlbnRpdHluYW1lIFwiJmFub3RoZXJFbGVtZW50O1wiPlxuXG4gICAgLy9JbnRlcm5hbCBlbnRpdGllcyBhcmUgc3VwcG9ydGVkXG4gICAgLy8gICAgPCFFTlRJVFkgZW50aXR5bmFtZSBcInJlcGxhY2VtZW50IHRleHRcIj5cbiAgICBcbiAgICAvL3JlYWQgRW50aXR5TmFtZVxuICAgIGxldCBlbnRpdHlOYW1lID0gXCJcIjtcbiAgICBmb3IgKDsgaSA8IHhtbERhdGEubGVuZ3RoICYmICh4bWxEYXRhW2ldICE9PSBcIidcIiAmJiB4bWxEYXRhW2ldICE9PSAnXCInICk7IGkrKykge1xuICAgICAgICAvLyBpZih4bWxEYXRhW2ldID09PSBcIiBcIikgY29udGludWU7XG4gICAgICAgIC8vIGVsc2UgXG4gICAgICAgIGVudGl0eU5hbWUgKz0geG1sRGF0YVtpXTtcbiAgICB9XG4gICAgZW50aXR5TmFtZSA9IGVudGl0eU5hbWUudHJpbSgpO1xuICAgIGlmKGVudGl0eU5hbWUuaW5kZXhPZihcIiBcIikgIT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHRlcm5hbCBlbnRpdGVzIGFyZSBub3Qgc3VwcG9ydGVkXCIpO1xuXG4gICAgLy9yZWFkIEVudGl0eSBWYWx1ZVxuICAgIGNvbnN0IHN0YXJ0Q2hhciA9IHhtbERhdGFbaSsrXTtcbiAgICBsZXQgdmFsID0gXCJcIlxuICAgIGZvciAoOyBpIDwgeG1sRGF0YS5sZW5ndGggJiYgeG1sRGF0YVtpXSAhPT0gc3RhcnRDaGFyIDsgaSsrKSB7XG4gICAgICAgIHZhbCArPSB4bWxEYXRhW2ldO1xuICAgIH1cbiAgICByZXR1cm4gW2VudGl0eU5hbWUsIHZhbCwgaV07XG59XG5cbmZ1bmN0aW9uIGlzQ29tbWVudCh4bWxEYXRhLCBpKXtcbiAgICBpZih4bWxEYXRhW2krMV0gPT09ICchJyAmJlxuICAgIHhtbERhdGFbaSsyXSA9PT0gJy0nICYmXG4gICAgeG1sRGF0YVtpKzNdID09PSAnLScpIHJldHVybiB0cnVlXG4gICAgcmV0dXJuIGZhbHNlXG59XG5mdW5jdGlvbiBpc0VudGl0eSh4bWxEYXRhLCBpKXtcbiAgICBpZih4bWxEYXRhW2krMV0gPT09ICchJyAmJlxuICAgIHhtbERhdGFbaSsyXSA9PT0gJ0UnICYmXG4gICAgeG1sRGF0YVtpKzNdID09PSAnTicgJiZcbiAgICB4bWxEYXRhW2krNF0gPT09ICdUJyAmJlxuICAgIHhtbERhdGFbaSs1XSA9PT0gJ0knICYmXG4gICAgeG1sRGF0YVtpKzZdID09PSAnVCcgJiZcbiAgICB4bWxEYXRhW2krN10gPT09ICdZJykgcmV0dXJuIHRydWVcbiAgICByZXR1cm4gZmFsc2Vcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudCh4bWxEYXRhLCBpKXtcbiAgICBpZih4bWxEYXRhW2krMV0gPT09ICchJyAmJlxuICAgIHhtbERhdGFbaSsyXSA9PT0gJ0UnICYmXG4gICAgeG1sRGF0YVtpKzNdID09PSAnTCcgJiZcbiAgICB4bWxEYXRhW2krNF0gPT09ICdFJyAmJlxuICAgIHhtbERhdGFbaSs1XSA9PT0gJ00nICYmXG4gICAgeG1sRGF0YVtpKzZdID09PSAnRScgJiZcbiAgICB4bWxEYXRhW2krN10gPT09ICdOJyAmJlxuICAgIHhtbERhdGFbaSs4XSA9PT0gJ1QnKSByZXR1cm4gdHJ1ZVxuICAgIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBpc0F0dGxpc3QoeG1sRGF0YSwgaSl7XG4gICAgaWYoeG1sRGF0YVtpKzFdID09PSAnIScgJiZcbiAgICB4bWxEYXRhW2krMl0gPT09ICdBJyAmJlxuICAgIHhtbERhdGFbaSszXSA9PT0gJ1QnICYmXG4gICAgeG1sRGF0YVtpKzRdID09PSAnVCcgJiZcbiAgICB4bWxEYXRhW2krNV0gPT09ICdMJyAmJlxuICAgIHhtbERhdGFbaSs2XSA9PT0gJ0knICYmXG4gICAgeG1sRGF0YVtpKzddID09PSAnUycgJiZcbiAgICB4bWxEYXRhW2krOF0gPT09ICdUJykgcmV0dXJuIHRydWVcbiAgICByZXR1cm4gZmFsc2Vcbn1cbmZ1bmN0aW9uIGlzTm90YXRpb24oeG1sRGF0YSwgaSl7XG4gICAgaWYoeG1sRGF0YVtpKzFdID09PSAnIScgJiZcbiAgICB4bWxEYXRhW2krMl0gPT09ICdOJyAmJlxuICAgIHhtbERhdGFbaSszXSA9PT0gJ08nICYmXG4gICAgeG1sRGF0YVtpKzRdID09PSAnVCcgJiZcbiAgICB4bWxEYXRhW2krNV0gPT09ICdBJyAmJlxuICAgIHhtbERhdGFbaSs2XSA9PT0gJ1QnICYmXG4gICAgeG1sRGF0YVtpKzddID09PSAnSScgJiZcbiAgICB4bWxEYXRhW2krOF0gPT09ICdPJyAmJlxuICAgIHhtbERhdGFbaSs5XSA9PT0gJ04nKSByZXR1cm4gdHJ1ZVxuICAgIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUVudGl0eU5hbWUobmFtZSl7XG4gICAgaWYgKHV0aWwuaXNOYW1lKG5hbWUpKVxuXHRyZXR1cm4gbmFtZTtcbiAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBlbnRpdHkgbmFtZSAke25hbWV9YCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVhZERvY1R5cGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js":
/*!**********************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nconst defaultOptions = {\n    preserveOrder: false,\n    attributeNamePrefix: '@_',\n    attributesGroupName: false,\n    textNodeName: '#text',\n    ignoreAttributes: true,\n    removeNSPrefix: false, // remove NS from tag name or attribute name if true\n    allowBooleanAttributes: false, //a tag can have attributes without any value\n    //ignoreRootElement : false,\n    parseTagValue: true,\n    parseAttributeValue: false,\n    trimValues: true, //Trim string values of tag and attributes\n    cdataPropName: false,\n    numberParseOptions: {\n      hex: true,\n      leadingZeros: true,\n      eNotation: true\n    },\n    tagValueProcessor: function(tagName, val) {\n      return val;\n    },\n    attributeValueProcessor: function(attrName, val) {\n      return val;\n    },\n    stopNodes: [], //nested tags will not be parsed even for errors\n    alwaysCreateTextNode: false,\n    isArray: () => false,\n    commentPropName: false,\n    unpairedTags: [],\n    processEntities: true,\n    htmlEntities: false,\n    ignoreDeclaration: false,\n    ignorePiTags: false,\n    transformTagName: false,\n    transformAttributeName: false,\n    updateTag: function(tagName, jPath, attrs){\n      return tagName\n    },\n    // skipEmptyListItem: false\n};\n   \nconst buildOptions = function(options) {\n    return Object.assign({}, defaultOptions, options);\n};\n\nexports.buildOptions = buildOptions;\nexports.defaultOptions = defaultOptions;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvT3B0aW9uc0J1aWxkZXIuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBLG9CQUFvQjtBQUNwQixzQkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kaWFyeS1mcm9udC1lbmQvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvT3B0aW9uc0J1aWxkZXIuanM/NWI4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIHByZXNlcnZlT3JkZXI6IGZhbHNlLFxuICAgIGF0dHJpYnV0ZU5hbWVQcmVmaXg6ICdAXycsXG4gICAgYXR0cmlidXRlc0dyb3VwTmFtZTogZmFsc2UsXG4gICAgdGV4dE5vZGVOYW1lOiAnI3RleHQnLFxuICAgIGlnbm9yZUF0dHJpYnV0ZXM6IHRydWUsXG4gICAgcmVtb3ZlTlNQcmVmaXg6IGZhbHNlLCAvLyByZW1vdmUgTlMgZnJvbSB0YWcgbmFtZSBvciBhdHRyaWJ1dGUgbmFtZSBpZiB0cnVlXG4gICAgYWxsb3dCb29sZWFuQXR0cmlidXRlczogZmFsc2UsIC8vYSB0YWcgY2FuIGhhdmUgYXR0cmlidXRlcyB3aXRob3V0IGFueSB2YWx1ZVxuICAgIC8vaWdub3JlUm9vdEVsZW1lbnQgOiBmYWxzZSxcbiAgICBwYXJzZVRhZ1ZhbHVlOiB0cnVlLFxuICAgIHBhcnNlQXR0cmlidXRlVmFsdWU6IGZhbHNlLFxuICAgIHRyaW1WYWx1ZXM6IHRydWUsIC8vVHJpbSBzdHJpbmcgdmFsdWVzIG9mIHRhZyBhbmQgYXR0cmlidXRlc1xuICAgIGNkYXRhUHJvcE5hbWU6IGZhbHNlLFxuICAgIG51bWJlclBhcnNlT3B0aW9uczoge1xuICAgICAgaGV4OiB0cnVlLFxuICAgICAgbGVhZGluZ1plcm9zOiB0cnVlLFxuICAgICAgZU5vdGF0aW9uOiB0cnVlXG4gICAgfSxcbiAgICB0YWdWYWx1ZVByb2Nlc3NvcjogZnVuY3Rpb24odGFnTmFtZSwgdmFsKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG4gICAgYXR0cmlidXRlVmFsdWVQcm9jZXNzb3I6IGZ1bmN0aW9uKGF0dHJOYW1lLCB2YWwpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcbiAgICBzdG9wTm9kZXM6IFtdLCAvL25lc3RlZCB0YWdzIHdpbGwgbm90IGJlIHBhcnNlZCBldmVuIGZvciBlcnJvcnNcbiAgICBhbHdheXNDcmVhdGVUZXh0Tm9kZTogZmFsc2UsXG4gICAgaXNBcnJheTogKCkgPT4gZmFsc2UsXG4gICAgY29tbWVudFByb3BOYW1lOiBmYWxzZSxcbiAgICB1bnBhaXJlZFRhZ3M6IFtdLFxuICAgIHByb2Nlc3NFbnRpdGllczogdHJ1ZSxcbiAgICBodG1sRW50aXRpZXM6IGZhbHNlLFxuICAgIGlnbm9yZURlY2xhcmF0aW9uOiBmYWxzZSxcbiAgICBpZ25vcmVQaVRhZ3M6IGZhbHNlLFxuICAgIHRyYW5zZm9ybVRhZ05hbWU6IGZhbHNlLFxuICAgIHRyYW5zZm9ybUF0dHJpYnV0ZU5hbWU6IGZhbHNlLFxuICAgIHVwZGF0ZVRhZzogZnVuY3Rpb24odGFnTmFtZSwgalBhdGgsIGF0dHJzKXtcbiAgICAgIHJldHVybiB0YWdOYW1lXG4gICAgfSxcbiAgICAvLyBza2lwRW1wdHlMaXN0SXRlbTogZmFsc2Vcbn07XG4gICBcbmNvbnN0IGJ1aWxkT3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xufTtcblxuZXhwb3J0cy5idWlsZE9wdGlvbnMgPSBidWlsZE9wdGlvbnM7XG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js":
/*!************************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n///@ts-check\n\nconst util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/fast-xml-parser/src/util.js\");\nconst xmlNode = __webpack_require__(/*! ./xmlNode */ \"(ssr)/./node_modules/fast-xml-parser/src/xmlparser/xmlNode.js\");\nconst readDocType = __webpack_require__(/*! ./DocTypeReader */ \"(ssr)/./node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js\");\nconst toNumber = __webpack_require__(/*! strnum */ \"(ssr)/./node_modules/strnum/strnum.js\");\n\nconst regx =\n  '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'\n  .replace(/NAME/g, util.nameRegexp);\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\nclass OrderedObjParser{\n  constructor(options){\n    this.options = options;\n    this.currentNode = null;\n    this.tagsNodeStack = [];\n    this.docTypeEntities = {};\n    this.lastEntities = {\n      \"apos\" : { regex: /&(apos|#39|#x27);/g, val : \"'\"},\n      \"gt\" : { regex: /&(gt|#62|#x3E);/g, val : \">\"},\n      \"lt\" : { regex: /&(lt|#60|#x3C);/g, val : \"<\"},\n      \"quot\" : { regex: /&(quot|#34|#x22);/g, val : \"\\\"\"},\n    };\n    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : \"&\"};\n    this.htmlEntities = {\n      \"space\": { regex: /&(nbsp|#160);/g, val: \" \" },\n      // \"lt\" : { regex: /&(lt|#60);/g, val: \"<\" },\n      // \"gt\" : { regex: /&(gt|#62);/g, val: \">\" },\n      // \"amp\" : { regex: /&(amp|#38);/g, val: \"&\" },\n      // \"quot\" : { regex: /&(quot|#34);/g, val: \"\\\"\" },\n      // \"apos\" : { regex: /&(apos|#39);/g, val: \"'\" },\n      \"cent\" : { regex: /&(cent|#162);/g, val: \"¢\" },\n      \"pound\" : { regex: /&(pound|#163);/g, val: \"£\" },\n      \"yen\" : { regex: /&(yen|#165);/g, val: \"¥\" },\n      \"euro\" : { regex: /&(euro|#8364);/g, val: \"€\" },\n      \"copyright\" : { regex: /&(copy|#169);/g, val: \"©\" },\n      \"reg\" : { regex: /&(reg|#174);/g, val: \"®\" },\n      \"inr\" : { regex: /&(inr|#8377);/g, val: \"₹\" },\n    };\n    this.addExternalEntities = addExternalEntities;\n    this.parseXml = parseXml;\n    this.parseTextData = parseTextData;\n    this.resolveNameSpace = resolveNameSpace;\n    this.buildAttributesMap = buildAttributesMap;\n    this.isItStopNode = isItStopNode;\n    this.replaceEntitiesValue = replaceEntitiesValue;\n    this.readStopNodeData = readStopNodeData;\n    this.saveTextToParentTag = saveTextToParentTag;\n    this.addChild = addChild;\n  }\n\n}\n\nfunction addExternalEntities(externalEntities){\n  const entKeys = Object.keys(externalEntities);\n  for (let i = 0; i < entKeys.length; i++) {\n    const ent = entKeys[i];\n    this.lastEntities[ent] = {\n       regex: new RegExp(\"&\"+ent+\";\",\"g\"),\n       val : externalEntities[ent]\n    }\n  }\n}\n\n/**\n * @param {string} val\n * @param {string} tagName\n * @param {string} jPath\n * @param {boolean} dontTrim\n * @param {boolean} hasAttributes\n * @param {boolean} isLeafNode\n * @param {boolean} escapeEntities\n */\nfunction parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\n  if (val !== undefined) {\n    if (this.options.trimValues && !dontTrim) {\n      val = val.trim();\n    }\n    if(val.length > 0){\n      if(!escapeEntities) val = this.replaceEntitiesValue(val);\n      \n      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);\n      if(newval === null || newval === undefined){\n        //don't parse\n        return val;\n      }else if(typeof newval !== typeof val || newval !== val){\n        //overwrite\n        return newval;\n      }else if(this.options.trimValues){\n        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n      }else{\n        const trimmedVal = val.trim();\n        if(trimmedVal === val){\n          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n        }else{\n          return val;\n        }\n      }\n    }\n  }\n}\n\nfunction resolveNameSpace(tagname) {\n  if (this.options.removeNSPrefix) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])([\\\\s\\\\S]*?)\\\\3)?', 'gm');\n\nfunction buildAttributesMap(attrStr, jPath, tagName) {\n  if (!this.options.ignoreAttributes && typeof attrStr === 'string') {\n    // attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = util.getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = this.resolveNameSpace(matches[i][1]);\n      let oldVal = matches[i][4];\n      let aName = this.options.attributeNamePrefix + attrName;\n      if (attrName.length) {\n        if (this.options.transformAttributeName) {\n          aName = this.options.transformAttributeName(aName);\n        }\n        if(aName === \"__proto__\") aName  = \"#__proto__\";\n        if (oldVal !== undefined) {\n          if (this.options.trimValues) {\n            oldVal = oldVal.trim();\n          }\n          oldVal = this.replaceEntitiesValue(oldVal);\n          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\n          if(newVal === null || newVal === undefined){\n            //don't parse\n            attrs[aName] = oldVal;\n          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){\n            //overwrite\n            attrs[aName] = newVal;\n          }else{\n            //parse\n            attrs[aName] = parseValue(\n              oldVal,\n              this.options.parseAttributeValue,\n              this.options.numberParseOptions\n            );\n          }\n        } else if (this.options.allowBooleanAttributes) {\n          attrs[aName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (this.options.attributesGroupName) {\n      const attrCollection = {};\n      attrCollection[this.options.attributesGroupName] = attrs;\n      return attrCollection;\n    }\n    return attrs\n  }\n}\n\nconst parseXml = function(xmlData) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\"); //TODO: remove this line\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  let textData = \"\";\n  let jPath = \"\";\n  for(let i=0; i< xmlData.length; i++){//for each char in XML data\n    const ch = xmlData[i];\n    if(ch === '<'){\n      // const nextIndex = i+1;\n      // const _2ndChar = xmlData[nextIndex];\n      if( xmlData[i+1] === '/') {//Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\")\n        let tagName = xmlData.substring(i+2,closeIndex).trim();\n\n        if(this.options.removeNSPrefix){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n          }\n        }\n\n        if(this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n\n        if(currentNode){\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        }\n\n        //check if last tag of nested tag was unpaired tag\n        const lastTagName = jPath.substring(jPath.lastIndexOf(\".\")+1);\n        if(tagName && this.options.unpairedTags.indexOf(tagName) !== -1 ){\n          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);\n        }\n        let propIndex = 0\n        if(lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1 ){\n          propIndex = jPath.lastIndexOf('.', jPath.lastIndexOf('.')-1)\n          this.tagsNodeStack.pop();\n        }else{\n          propIndex = jPath.lastIndexOf(\".\");\n        }\n        jPath = jPath.substring(0, propIndex);\n\n        currentNode = this.tagsNodeStack.pop();//avoid recursion, set the parent tag scope\n        textData = \"\";\n        i = closeIndex;\n      } else if( xmlData[i+1] === '?') {\n\n        let tagData = readTagExp(xmlData,i, false, \"?>\");\n        if(!tagData) throw new Error(\"Pi Tag is not closed.\");\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        if( (this.options.ignoreDeclaration && tagData.tagName === \"?xml\") || this.options.ignorePiTags){\n\n        }else{\n  \n          const childNode = new xmlNode(tagData.tagName);\n          childNode.add(this.options.textNodeName, \"\");\n          \n          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);\n          }\n          this.addChild(currentNode, childNode, jPath)\n\n        }\n\n\n        i = tagData.closeIndex + 1;\n      } else if(xmlData.substr(i + 1, 3) === '!--') {\n        const endIndex = findClosingIndex(xmlData, \"-->\", i+4, \"Comment is not closed.\")\n        if(this.options.commentPropName){\n          const comment = xmlData.substring(i + 4, endIndex - 2);\n\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);\n        }\n        i = endIndex;\n      } else if( xmlData.substr(i + 1, 2) === '!D') {\n        const result = readDocType(xmlData, i);\n        this.docTypeEntities = result.entities;\n        i = result.i;\n      }else if(xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n        const tagExp = xmlData.substring(i + 9,closeIndex);\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n        //cdata should be set even if it is 0 length string\n        if(this.options.cdataPropName){\n          // let val = this.parseTextData(tagExp, this.options.cdataPropName, jPath + \".\" + this.options.cdataPropName, true, false, true);\n          // if(!val) val = \"\";\n          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);\n        }else{\n          let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);\n          if(val == undefined) val = \"\";\n          currentNode.add(this.options.textNodeName, val);\n        }\n        \n        i = closeIndex + 2;\n      }else {//Opening tag\n        let result = readTagExp(xmlData,i, this.options.removeNSPrefix);\n        let tagName= result.tagName;\n        const rawTagName = result.rawTagName;\n        let tagExp = result.tagExp;\n        let attrExpPresent = result.attrExpPresent;\n        let closeIndex = result.closeIndex;\n\n        if (this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n        \n        //save text as child node\n        if (currentNode && textData) {\n          if(currentNode.tagname !== '!xml'){\n            //when nested tag is found\n            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\n          }\n        }\n\n        //check if last tag was unpaired tag\n        const lastTag = currentNode;\n        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){\n          currentNode = this.tagsNodeStack.pop();\n          jPath = jPath.substring(0, jPath.lastIndexOf(\".\"));\n        }\n        if(tagName !== xmlObj.tagname){\n          jPath += jPath ? \".\" + tagName : tagName;\n        }\n        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {\n          let tagContent = \"\";\n          //self-closing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            i = result.closeIndex;\n          }\n          //unpaired tag\n          else if(this.options.unpairedTags.indexOf(tagName) !== -1){\n            i = result.closeIndex;\n          }\n          //normal tag\n          else{\n            //read until closing tag is found\n            const result = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);\n            if(!result) throw new Error(`Unexpected end of ${rawTagName}`);\n            i = result.i;\n            tagContent = result.tagContent;\n          }\n\n          const childNode = new xmlNode(tagName);\n          if(tagName !== tagExp && attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n          }\n          if(tagContent) {\n            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);\n          }\n          \n          jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          childNode.add(this.options.textNodeName, tagContent);\n          \n          this.addChild(currentNode, childNode, jPath)\n        }else{\n  //selfClosing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n              tagName = tagName.substr(0, tagName.length - 1);\n              jPath = jPath.substr(0, jPath.length - 1);\n              tagExp = tagName;\n            }else{\n              tagExp = tagExp.substr(0, tagExp.length - 1);\n            }\n            \n            if(this.options.transformTagName) {\n              tagName = this.options.transformTagName(tagName);\n            }\n\n            const childNode = new xmlNode(tagName);\n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n            this.addChild(currentNode, childNode, jPath)\n            jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          }\n    //opening tag\n          else{\n            const childNode = new xmlNode( tagName);\n            this.tagsNodeStack.push(currentNode);\n            \n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n            this.addChild(currentNode, childNode, jPath)\n            currentNode = childNode;\n          }\n          textData = \"\";\n          i = closeIndex;\n        }\n      }\n    }else{\n      textData += xmlData[i];\n    }\n  }\n  return xmlObj.child;\n}\n\nfunction addChild(currentNode, childNode, jPath){\n  const result = this.options.updateTag(childNode.tagname, jPath, childNode[\":@\"])\n  if(result === false){\n  }else if(typeof result === \"string\"){\n    childNode.tagname = result\n    currentNode.addChild(childNode);\n  }else{\n    currentNode.addChild(childNode);\n  }\n}\n\nconst replaceEntitiesValue = function(val){\n\n  if(this.options.processEntities){\n    for(let entityName in this.docTypeEntities){\n      const entity = this.docTypeEntities[entityName];\n      val = val.replace( entity.regx, entity.val);\n    }\n    for(let entityName in this.lastEntities){\n      const entity = this.lastEntities[entityName];\n      val = val.replace( entity.regex, entity.val);\n    }\n    if(this.options.htmlEntities){\n      for(let entityName in this.htmlEntities){\n        const entity = this.htmlEntities[entityName];\n        val = val.replace( entity.regex, entity.val);\n      }\n    }\n    val = val.replace( this.ampEntity.regex, this.ampEntity.val);\n  }\n  return val;\n}\nfunction saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\n  if (textData) { //store previously collected data as textNode\n    if(isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0\n    \n    textData = this.parseTextData(textData,\n      currentNode.tagname,\n      jPath,\n      false,\n      currentNode[\":@\"] ? Object.keys(currentNode[\":@\"]).length !== 0 : false,\n      isLeafNode);\n\n    if (textData !== undefined && textData !== \"\")\n      currentNode.add(this.options.textNodeName, textData);\n    textData = \"\";\n  }\n  return textData;\n}\n\n//TODO: use jPath to simplify the logic\n/**\n * \n * @param {string[]} stopNodes \n * @param {string} jPath\n * @param {string} currentTagName \n */\nfunction isItStopNode(stopNodes, jPath, currentTagName){\n  const allNodesExp = \"*.\" + currentTagName;\n  for (const stopNodePath in stopNodes) {\n    const stopNodeExp = stopNodes[stopNodePath];\n    if( allNodesExp === stopNodeExp || jPath === stopNodeExp  ) return true;\n  }\n  return false;\n}\n\n/**\n * Returns the tag Expression and where it is ending handling single-double quotes situation\n * @param {string} xmlData \n * @param {number} i starting index\n * @returns \n */\nfunction tagExpWithClosingIndex(xmlData, i, closingChar = \">\"){\n  let attrBoundary;\n  let tagExp = \"\";\n  for (let index = i; index < xmlData.length; index++) {\n    let ch = xmlData[index];\n    if (attrBoundary) {\n        if (ch === attrBoundary) attrBoundary = \"\";//reset\n    } else if (ch === '\"' || ch === \"'\") {\n        attrBoundary = ch;\n    } else if (ch === closingChar[0]) {\n      if(closingChar[1]){\n        if(xmlData[index + 1] === closingChar[1]){\n          return {\n            data: tagExp,\n            index: index\n          }\n        }\n      }else{\n        return {\n          data: tagExp,\n          index: index\n        }\n      }\n    } else if (ch === '\\t') {\n      ch = \" \"\n    }\n    tagExp += ch;\n  }\n}\n\nfunction findClosingIndex(xmlData, str, i, errMsg){\n  const closingIndex = xmlData.indexOf(str, i);\n  if(closingIndex === -1){\n    throw new Error(errMsg)\n  }else{\n    return closingIndex + str.length - 1;\n  }\n}\n\nfunction readTagExp(xmlData,i, removeNSPrefix, closingChar = \">\"){\n  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);\n  if(!result) return;\n  let tagExp = result.data;\n  const closeIndex = result.index;\n  const separatorIndex = tagExp.search(/\\s/);\n  let tagName = tagExp;\n  let attrExpPresent = true;\n  if(separatorIndex !== -1){//separate tag name and attributes expression\n    tagName = tagExp.substr(0, separatorIndex).replace(/\\s\\s*$/, '');\n    tagExp = tagExp.substr(separatorIndex + 1);\n  }\n\n  const rawTagName = tagName;\n  if(removeNSPrefix){\n    const colonIndex = tagName.indexOf(\":\");\n    if(colonIndex !== -1){\n      tagName = tagName.substr(colonIndex+1);\n      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\n    }\n  }\n\n  return {\n    tagName: tagName,\n    tagExp: tagExp,\n    closeIndex: closeIndex,\n    attrExpPresent: attrExpPresent,\n    rawTagName: rawTagName,\n  }\n}\n/**\n * find paired tag for a stop node\n * @param {string} xmlData \n * @param {string} tagName \n * @param {number} i \n */\nfunction readStopNodeData(xmlData, tagName, i){\n  const startIndex = i;\n  // Starting at 1 since we already have an open tag\n  let openTagCount = 1;\n\n  for (; i < xmlData.length; i++) {\n    if( xmlData[i] === \"<\"){ \n      if (xmlData[i+1] === \"/\") {//close tag\n          const closeIndex = findClosingIndex(xmlData, \">\", i, `${tagName} is not closed`);\n          let closeTagName = xmlData.substring(i+2,closeIndex).trim();\n          if(closeTagName === tagName){\n            openTagCount--;\n            if (openTagCount === 0) {\n              return {\n                tagContent: xmlData.substring(startIndex, i),\n                i : closeIndex\n              }\n            }\n          }\n          i=closeIndex;\n        } else if(xmlData[i+1] === '?') { \n          const closeIndex = findClosingIndex(xmlData, \"?>\", i+1, \"StopNode is not closed.\")\n          i=closeIndex;\n        } else if(xmlData.substr(i + 1, 3) === '!--') { \n          const closeIndex = findClosingIndex(xmlData, \"-->\", i+3, \"StopNode is not closed.\")\n          i=closeIndex;\n        } else if(xmlData.substr(i + 1, 2) === '![') { \n          const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"StopNode is not closed.\") - 2;\n          i=closeIndex;\n        } else {\n          const tagData = readTagExp(xmlData, i, '>')\n\n          if (tagData) {\n            const openTagName = tagData && tagData.tagName;\n            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== \"/\") {\n              openTagCount++;\n            }\n            i=tagData.closeIndex;\n          }\n        }\n      }\n  }//end for loop\n}\n\nfunction parseValue(val, shouldParse, options) {\n  if (shouldParse && typeof val === 'string') {\n    //console.log(options)\n    const newval = val.trim();\n    if(newval === 'true' ) return true;\n    else if(newval === 'false' ) return false;\n    else return toNumber(val, options);\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n\n\nmodule.exports = OrderedObjParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvT3JkZXJlZE9ialBhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyxpRUFBUztBQUM5QixnQkFBZ0IsbUJBQU8sQ0FBQyxnRkFBVztBQUNuQyxvQkFBb0IsbUJBQU8sQ0FBQyw0RkFBaUI7QUFDN0MsaUJBQWlCLG1CQUFPLENBQUMscURBQVE7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlCQUF5QixjQUFjO0FBQ3hELGVBQWUsdUJBQXVCLGNBQWM7QUFDcEQsZUFBZSx1QkFBdUIsY0FBYztBQUNwRCxpQkFBaUIseUJBQXlCLGVBQWU7QUFDekQ7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0EsaUJBQWlCLHFCQUFxQixjQUFjO0FBQ3BELGtCQUFrQixrQkFBa0IsY0FBYztBQUNsRCxrQkFBa0Isa0JBQWtCLGNBQWM7QUFDbEQsbUJBQW1CLG1CQUFtQixjQUFjO0FBQ3BELG9CQUFvQixvQkFBb0IsZUFBZTtBQUN2RCxvQkFBb0Isb0JBQW9CLGNBQWM7QUFDdEQsaUJBQWlCLHFCQUFxQixjQUFjO0FBQ3BELGtCQUFrQixzQkFBc0IsY0FBYztBQUN0RCxnQkFBZ0Isb0JBQW9CLGNBQWM7QUFDbEQsaUJBQWlCLHNCQUFzQixjQUFjO0FBQ3JELHNCQUFzQixxQkFBcUIsY0FBYztBQUN6RCxnQkFBZ0Isb0JBQW9CLGNBQWM7QUFDbEQsZ0JBQWdCLHFCQUFxQixjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUIsS0FBSztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxRQUFRO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0REFBNEQsd0NBQXdDO0FBQ3BHO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsdUNBQXVDO0FBQ2pHLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLE1BQU07QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFdBQVc7QUFDeEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRCxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLG9CQUFvQjtBQUM3QjtBQUNBLGlDQUFpQztBQUNqQyxrRUFBa0UsU0FBUztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSIsInNvdXJjZXMiOlsid2VicGFjazovL2RpYXJ5LWZyb250LWVuZC8uL25vZGVfbW9kdWxlcy9mYXN0LXhtbC1wYXJzZXIvc3JjL3htbHBhcnNlci9PcmRlcmVkT2JqUGFyc2VyLmpzP2M5OTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8vQHRzLWNoZWNrXG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5jb25zdCB4bWxOb2RlID0gcmVxdWlyZSgnLi94bWxOb2RlJyk7XG5jb25zdCByZWFkRG9jVHlwZSA9IHJlcXVpcmUoXCIuL0RvY1R5cGVSZWFkZXJcIik7XG5jb25zdCB0b051bWJlciA9IHJlcXVpcmUoXCJzdHJudW1cIik7XG5cbmNvbnN0IHJlZ3ggPVxuICAnPCgoIVxcXFxbQ0RBVEFcXFxcWyhbXFxcXHNcXFxcU10qPykoXV0+KSl8KChOQU1FOik/KE5BTUUpKShbXj5dKik+fCgoXFxcXC8pKE5BTUUpXFxcXHMqPikpKFtePF0qKSdcbiAgLnJlcGxhY2UoL05BTUUvZywgdXRpbC5uYW1lUmVnZXhwKTtcblxuLy9jb25zdCB0YWdzUmVneCA9IG5ldyBSZWdFeHAoXCI8KFxcXFwvP1tcXFxcdzpcXFxcLVxcLl9dKykoW14+XSopPihcXFxccypcIitjZGF0YVJlZ3grXCIpKihbXjxdKyk/XCIsXCJnXCIpO1xuLy9jb25zdCB0YWdzUmVneCA9IG5ldyBSZWdFeHAoXCI8KFxcXFwvPykoKFxcXFx3KjopPyhbXFxcXHc6XFxcXC1cXC5fXSspKShbXj5dKik+KFtePF0qKShcIitjZGF0YVJlZ3grXCIoW148XSopKSooW148XSspP1wiLFwiZ1wiKTtcblxuY2xhc3MgT3JkZXJlZE9ialBhcnNlcntcbiAgY29uc3RydWN0b3Iob3B0aW9ucyl7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmN1cnJlbnROb2RlID0gbnVsbDtcbiAgICB0aGlzLnRhZ3NOb2RlU3RhY2sgPSBbXTtcbiAgICB0aGlzLmRvY1R5cGVFbnRpdGllcyA9IHt9O1xuICAgIHRoaXMubGFzdEVudGl0aWVzID0ge1xuICAgICAgXCJhcG9zXCIgOiB7IHJlZ2V4OiAvJihhcG9zfCMzOXwjeDI3KTsvZywgdmFsIDogXCInXCJ9LFxuICAgICAgXCJndFwiIDogeyByZWdleDogLyYoZ3R8IzYyfCN4M0UpOy9nLCB2YWwgOiBcIj5cIn0sXG4gICAgICBcImx0XCIgOiB7IHJlZ2V4OiAvJihsdHwjNjB8I3gzQyk7L2csIHZhbCA6IFwiPFwifSxcbiAgICAgIFwicXVvdFwiIDogeyByZWdleDogLyYocXVvdHwjMzR8I3gyMik7L2csIHZhbCA6IFwiXFxcIlwifSxcbiAgICB9O1xuICAgIHRoaXMuYW1wRW50aXR5ID0geyByZWdleDogLyYoYW1wfCMzOHwjeDI2KTsvZywgdmFsIDogXCImXCJ9O1xuICAgIHRoaXMuaHRtbEVudGl0aWVzID0ge1xuICAgICAgXCJzcGFjZVwiOiB7IHJlZ2V4OiAvJihuYnNwfCMxNjApOy9nLCB2YWw6IFwiIFwiIH0sXG4gICAgICAvLyBcImx0XCIgOiB7IHJlZ2V4OiAvJihsdHwjNjApOy9nLCB2YWw6IFwiPFwiIH0sXG4gICAgICAvLyBcImd0XCIgOiB7IHJlZ2V4OiAvJihndHwjNjIpOy9nLCB2YWw6IFwiPlwiIH0sXG4gICAgICAvLyBcImFtcFwiIDogeyByZWdleDogLyYoYW1wfCMzOCk7L2csIHZhbDogXCImXCIgfSxcbiAgICAgIC8vIFwicXVvdFwiIDogeyByZWdleDogLyYocXVvdHwjMzQpOy9nLCB2YWw6IFwiXFxcIlwiIH0sXG4gICAgICAvLyBcImFwb3NcIiA6IHsgcmVnZXg6IC8mKGFwb3N8IzM5KTsvZywgdmFsOiBcIidcIiB9LFxuICAgICAgXCJjZW50XCIgOiB7IHJlZ2V4OiAvJihjZW50fCMxNjIpOy9nLCB2YWw6IFwiwqJcIiB9LFxuICAgICAgXCJwb3VuZFwiIDogeyByZWdleDogLyYocG91bmR8IzE2Myk7L2csIHZhbDogXCLCo1wiIH0sXG4gICAgICBcInllblwiIDogeyByZWdleDogLyYoeWVufCMxNjUpOy9nLCB2YWw6IFwiwqVcIiB9LFxuICAgICAgXCJldXJvXCIgOiB7IHJlZ2V4OiAvJihldXJvfCM4MzY0KTsvZywgdmFsOiBcIuKCrFwiIH0sXG4gICAgICBcImNvcHlyaWdodFwiIDogeyByZWdleDogLyYoY29weXwjMTY5KTsvZywgdmFsOiBcIsKpXCIgfSxcbiAgICAgIFwicmVnXCIgOiB7IHJlZ2V4OiAvJihyZWd8IzE3NCk7L2csIHZhbDogXCLCrlwiIH0sXG4gICAgICBcImluclwiIDogeyByZWdleDogLyYoaW5yfCM4Mzc3KTsvZywgdmFsOiBcIuKCuVwiIH0sXG4gICAgfTtcbiAgICB0aGlzLmFkZEV4dGVybmFsRW50aXRpZXMgPSBhZGRFeHRlcm5hbEVudGl0aWVzO1xuICAgIHRoaXMucGFyc2VYbWwgPSBwYXJzZVhtbDtcbiAgICB0aGlzLnBhcnNlVGV4dERhdGEgPSBwYXJzZVRleHREYXRhO1xuICAgIHRoaXMucmVzb2x2ZU5hbWVTcGFjZSA9IHJlc29sdmVOYW1lU3BhY2U7XG4gICAgdGhpcy5idWlsZEF0dHJpYnV0ZXNNYXAgPSBidWlsZEF0dHJpYnV0ZXNNYXA7XG4gICAgdGhpcy5pc0l0U3RvcE5vZGUgPSBpc0l0U3RvcE5vZGU7XG4gICAgdGhpcy5yZXBsYWNlRW50aXRpZXNWYWx1ZSA9IHJlcGxhY2VFbnRpdGllc1ZhbHVlO1xuICAgIHRoaXMucmVhZFN0b3BOb2RlRGF0YSA9IHJlYWRTdG9wTm9kZURhdGE7XG4gICAgdGhpcy5zYXZlVGV4dFRvUGFyZW50VGFnID0gc2F2ZVRleHRUb1BhcmVudFRhZztcbiAgICB0aGlzLmFkZENoaWxkID0gYWRkQ2hpbGQ7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBhZGRFeHRlcm5hbEVudGl0aWVzKGV4dGVybmFsRW50aXRpZXMpe1xuICBjb25zdCBlbnRLZXlzID0gT2JqZWN0LmtleXMoZXh0ZXJuYWxFbnRpdGllcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW50S2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGVudCA9IGVudEtleXNbaV07XG4gICAgdGhpcy5sYXN0RW50aXRpZXNbZW50XSA9IHtcbiAgICAgICByZWdleDogbmV3IFJlZ0V4cChcIiZcIitlbnQrXCI7XCIsXCJnXCIpLFxuICAgICAgIHZhbCA6IGV4dGVybmFsRW50aXRpZXNbZW50XVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWxcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30galBhdGhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9udFRyaW1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzQXR0cmlidXRlc1xuICogQHBhcmFtIHtib29sZWFufSBpc0xlYWZOb2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVzY2FwZUVudGl0aWVzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlVGV4dERhdGEodmFsLCB0YWdOYW1lLCBqUGF0aCwgZG9udFRyaW0sIGhhc0F0dHJpYnV0ZXMsIGlzTGVhZk5vZGUsIGVzY2FwZUVudGl0aWVzKSB7XG4gIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudHJpbVZhbHVlcyAmJiAhZG9udFRyaW0pIHtcbiAgICAgIHZhbCA9IHZhbC50cmltKCk7XG4gICAgfVxuICAgIGlmKHZhbC5sZW5ndGggPiAwKXtcbiAgICAgIGlmKCFlc2NhcGVFbnRpdGllcykgdmFsID0gdGhpcy5yZXBsYWNlRW50aXRpZXNWYWx1ZSh2YWwpO1xuICAgICAgXG4gICAgICBjb25zdCBuZXd2YWwgPSB0aGlzLm9wdGlvbnMudGFnVmFsdWVQcm9jZXNzb3IodGFnTmFtZSwgdmFsLCBqUGF0aCwgaGFzQXR0cmlidXRlcywgaXNMZWFmTm9kZSk7XG4gICAgICBpZihuZXd2YWwgPT09IG51bGwgfHwgbmV3dmFsID09PSB1bmRlZmluZWQpe1xuICAgICAgICAvL2Rvbid0IHBhcnNlXG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9ZWxzZSBpZih0eXBlb2YgbmV3dmFsICE9PSB0eXBlb2YgdmFsIHx8IG5ld3ZhbCAhPT0gdmFsKXtcbiAgICAgICAgLy9vdmVyd3JpdGVcbiAgICAgICAgcmV0dXJuIG5ld3ZhbDtcbiAgICAgIH1lbHNlIGlmKHRoaXMub3B0aW9ucy50cmltVmFsdWVzKXtcbiAgICAgICAgcmV0dXJuIHBhcnNlVmFsdWUodmFsLCB0aGlzLm9wdGlvbnMucGFyc2VUYWdWYWx1ZSwgdGhpcy5vcHRpb25zLm51bWJlclBhcnNlT3B0aW9ucyk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgY29uc3QgdHJpbW1lZFZhbCA9IHZhbC50cmltKCk7XG4gICAgICAgIGlmKHRyaW1tZWRWYWwgPT09IHZhbCl7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlVmFsdWUodmFsLCB0aGlzLm9wdGlvbnMucGFyc2VUYWdWYWx1ZSwgdGhpcy5vcHRpb25zLm51bWJlclBhcnNlT3B0aW9ucyk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU5hbWVTcGFjZSh0YWduYW1lKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMucmVtb3ZlTlNQcmVmaXgpIHtcbiAgICBjb25zdCB0YWdzID0gdGFnbmFtZS5zcGxpdCgnOicpO1xuICAgIGNvbnN0IHByZWZpeCA9IHRhZ25hbWUuY2hhckF0KDApID09PSAnLycgPyAnLycgOiAnJztcbiAgICBpZiAodGFnc1swXSA9PT0gJ3htbG5zJykge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBpZiAodGFncy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHRhZ25hbWUgPSBwcmVmaXggKyB0YWdzWzFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFnbmFtZTtcbn1cblxuLy9UT0RPOiBjaGFuZ2UgcmVnZXggdG8gY2FwdHVyZSBOU1xuLy9jb25zdCBhdHRyc1JlZ3ggPSBuZXcgUmVnRXhwKFwiKFtcXFxcd1xcXFwtXFxcXC5cXFxcOl0rKVxcXFxzKj1cXFxccyooWydcXFwiXSkoKC58XFxuKSo/KVxcXFwyXCIsXCJnbVwiKTtcbmNvbnN0IGF0dHJzUmVneCA9IG5ldyBSZWdFeHAoJyhbXlxcXFxzPV0rKVxcXFxzKig9XFxcXHMqKFtcXCdcIl0pKFtcXFxcc1xcXFxTXSo/KVxcXFwzKT8nLCAnZ20nKTtcblxuZnVuY3Rpb24gYnVpbGRBdHRyaWJ1dGVzTWFwKGF0dHJTdHIsIGpQYXRoLCB0YWdOYW1lKSB7XG4gIGlmICghdGhpcy5vcHRpb25zLmlnbm9yZUF0dHJpYnV0ZXMgJiYgdHlwZW9mIGF0dHJTdHIgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gYXR0clN0ciA9IGF0dHJTdHIucmVwbGFjZSgvXFxyP1xcbi9nLCAnICcpO1xuICAgIC8vYXR0clN0ciA9IGF0dHJTdHIgfHwgYXR0clN0ci50cmltKCk7XG5cbiAgICBjb25zdCBtYXRjaGVzID0gdXRpbC5nZXRBbGxNYXRjaGVzKGF0dHJTdHIsIGF0dHJzUmVneCk7XG4gICAgY29uc3QgbGVuID0gbWF0Y2hlcy5sZW5ndGg7IC8vZG9uJ3QgbWFrZSBpdCBpbmxpbmVcbiAgICBjb25zdCBhdHRycyA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGF0dHJOYW1lID0gdGhpcy5yZXNvbHZlTmFtZVNwYWNlKG1hdGNoZXNbaV1bMV0pO1xuICAgICAgbGV0IG9sZFZhbCA9IG1hdGNoZXNbaV1bNF07XG4gICAgICBsZXQgYU5hbWUgPSB0aGlzLm9wdGlvbnMuYXR0cmlidXRlTmFtZVByZWZpeCArIGF0dHJOYW1lO1xuICAgICAgaWYgKGF0dHJOYW1lLmxlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRyYW5zZm9ybUF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgICBhTmFtZSA9IHRoaXMub3B0aW9ucy50cmFuc2Zvcm1BdHRyaWJ1dGVOYW1lKGFOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZihhTmFtZSA9PT0gXCJfX3Byb3RvX19cIikgYU5hbWUgID0gXCIjX19wcm90b19fXCI7XG4gICAgICAgIGlmIChvbGRWYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJpbVZhbHVlcykge1xuICAgICAgICAgICAgb2xkVmFsID0gb2xkVmFsLnRyaW0oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2xkVmFsID0gdGhpcy5yZXBsYWNlRW50aXRpZXNWYWx1ZShvbGRWYWwpO1xuICAgICAgICAgIGNvbnN0IG5ld1ZhbCA9IHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVWYWx1ZVByb2Nlc3NvcihhdHRyTmFtZSwgb2xkVmFsLCBqUGF0aCk7XG4gICAgICAgICAgaWYobmV3VmFsID09PSBudWxsIHx8IG5ld1ZhbCA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIC8vZG9uJ3QgcGFyc2VcbiAgICAgICAgICAgIGF0dHJzW2FOYW1lXSA9IG9sZFZhbDtcbiAgICAgICAgICB9ZWxzZSBpZih0eXBlb2YgbmV3VmFsICE9PSB0eXBlb2Ygb2xkVmFsIHx8IG5ld1ZhbCAhPT0gb2xkVmFsKXtcbiAgICAgICAgICAgIC8vb3ZlcndyaXRlXG4gICAgICAgICAgICBhdHRyc1thTmFtZV0gPSBuZXdWYWw7XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAvL3BhcnNlXG4gICAgICAgICAgICBhdHRyc1thTmFtZV0gPSBwYXJzZVZhbHVlKFxuICAgICAgICAgICAgICBvbGRWYWwsXG4gICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wYXJzZUF0dHJpYnV0ZVZhbHVlLFxuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMubnVtYmVyUGFyc2VPcHRpb25zXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuYWxsb3dCb29sZWFuQXR0cmlidXRlcykge1xuICAgICAgICAgIGF0dHJzW2FOYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFPYmplY3Qua2V5cyhhdHRycykubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuYXR0cmlidXRlc0dyb3VwTmFtZSkge1xuICAgICAgY29uc3QgYXR0ckNvbGxlY3Rpb24gPSB7fTtcbiAgICAgIGF0dHJDb2xsZWN0aW9uW3RoaXMub3B0aW9ucy5hdHRyaWJ1dGVzR3JvdXBOYW1lXSA9IGF0dHJzO1xuICAgICAgcmV0dXJuIGF0dHJDb2xsZWN0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cnNcbiAgfVxufVxuXG5jb25zdCBwYXJzZVhtbCA9IGZ1bmN0aW9uKHhtbERhdGEpIHtcbiAgeG1sRGF0YSA9IHhtbERhdGEucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKTsgLy9UT0RPOiByZW1vdmUgdGhpcyBsaW5lXG4gIGNvbnN0IHhtbE9iaiA9IG5ldyB4bWxOb2RlKCcheG1sJyk7XG4gIGxldCBjdXJyZW50Tm9kZSA9IHhtbE9iajtcbiAgbGV0IHRleHREYXRhID0gXCJcIjtcbiAgbGV0IGpQYXRoID0gXCJcIjtcbiAgZm9yKGxldCBpPTA7IGk8IHhtbERhdGEubGVuZ3RoOyBpKyspey8vZm9yIGVhY2ggY2hhciBpbiBYTUwgZGF0YVxuICAgIGNvbnN0IGNoID0geG1sRGF0YVtpXTtcbiAgICBpZihjaCA9PT0gJzwnKXtcbiAgICAgIC8vIGNvbnN0IG5leHRJbmRleCA9IGkrMTtcbiAgICAgIC8vIGNvbnN0IF8ybmRDaGFyID0geG1sRGF0YVtuZXh0SW5kZXhdO1xuICAgICAgaWYoIHhtbERhdGFbaSsxXSA9PT0gJy8nKSB7Ly9DbG9zaW5nIFRhZ1xuICAgICAgICBjb25zdCBjbG9zZUluZGV4ID0gZmluZENsb3NpbmdJbmRleCh4bWxEYXRhLCBcIj5cIiwgaSwgXCJDbG9zaW5nIFRhZyBpcyBub3QgY2xvc2VkLlwiKVxuICAgICAgICBsZXQgdGFnTmFtZSA9IHhtbERhdGEuc3Vic3RyaW5nKGkrMixjbG9zZUluZGV4KS50cmltKCk7XG5cbiAgICAgICAgaWYodGhpcy5vcHRpb25zLnJlbW92ZU5TUHJlZml4KXtcbiAgICAgICAgICBjb25zdCBjb2xvbkluZGV4ID0gdGFnTmFtZS5pbmRleE9mKFwiOlwiKTtcbiAgICAgICAgICBpZihjb2xvbkluZGV4ICE9PSAtMSl7XG4gICAgICAgICAgICB0YWdOYW1lID0gdGFnTmFtZS5zdWJzdHIoY29sb25JbmRleCsxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLm9wdGlvbnMudHJhbnNmb3JtVGFnTmFtZSkge1xuICAgICAgICAgIHRhZ05hbWUgPSB0aGlzLm9wdGlvbnMudHJhbnNmb3JtVGFnTmFtZSh0YWdOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGN1cnJlbnROb2RlKXtcbiAgICAgICAgICB0ZXh0RGF0YSA9IHRoaXMuc2F2ZVRleHRUb1BhcmVudFRhZyh0ZXh0RGF0YSwgY3VycmVudE5vZGUsIGpQYXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hlY2sgaWYgbGFzdCB0YWcgb2YgbmVzdGVkIHRhZyB3YXMgdW5wYWlyZWQgdGFnXG4gICAgICAgIGNvbnN0IGxhc3RUYWdOYW1lID0galBhdGguc3Vic3RyaW5nKGpQYXRoLmxhc3RJbmRleE9mKFwiLlwiKSsxKTtcbiAgICAgICAgaWYodGFnTmFtZSAmJiB0aGlzLm9wdGlvbnMudW5wYWlyZWRUYWdzLmluZGV4T2YodGFnTmFtZSkgIT09IC0xICl7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnBhaXJlZCB0YWcgY2FuIG5vdCBiZSB1c2VkIGFzIGNsb3NpbmcgdGFnOiA8LyR7dGFnTmFtZX0+YCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByb3BJbmRleCA9IDBcbiAgICAgICAgaWYobGFzdFRhZ05hbWUgJiYgdGhpcy5vcHRpb25zLnVucGFpcmVkVGFncy5pbmRleE9mKGxhc3RUYWdOYW1lKSAhPT0gLTEgKXtcbiAgICAgICAgICBwcm9wSW5kZXggPSBqUGF0aC5sYXN0SW5kZXhPZignLicsIGpQYXRoLmxhc3RJbmRleE9mKCcuJyktMSlcbiAgICAgICAgICB0aGlzLnRhZ3NOb2RlU3RhY2sucG9wKCk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIHByb3BJbmRleCA9IGpQYXRoLmxhc3RJbmRleE9mKFwiLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBqUGF0aCA9IGpQYXRoLnN1YnN0cmluZygwLCBwcm9wSW5kZXgpO1xuXG4gICAgICAgIGN1cnJlbnROb2RlID0gdGhpcy50YWdzTm9kZVN0YWNrLnBvcCgpOy8vYXZvaWQgcmVjdXJzaW9uLCBzZXQgdGhlIHBhcmVudCB0YWcgc2NvcGVcbiAgICAgICAgdGV4dERhdGEgPSBcIlwiO1xuICAgICAgICBpID0gY2xvc2VJbmRleDtcbiAgICAgIH0gZWxzZSBpZiggeG1sRGF0YVtpKzFdID09PSAnPycpIHtcblxuICAgICAgICBsZXQgdGFnRGF0YSA9IHJlYWRUYWdFeHAoeG1sRGF0YSxpLCBmYWxzZSwgXCI/PlwiKTtcbiAgICAgICAgaWYoIXRhZ0RhdGEpIHRocm93IG5ldyBFcnJvcihcIlBpIFRhZyBpcyBub3QgY2xvc2VkLlwiKTtcblxuICAgICAgICB0ZXh0RGF0YSA9IHRoaXMuc2F2ZVRleHRUb1BhcmVudFRhZyh0ZXh0RGF0YSwgY3VycmVudE5vZGUsIGpQYXRoKTtcbiAgICAgICAgaWYoICh0aGlzLm9wdGlvbnMuaWdub3JlRGVjbGFyYXRpb24gJiYgdGFnRGF0YS50YWdOYW1lID09PSBcIj94bWxcIikgfHwgdGhpcy5vcHRpb25zLmlnbm9yZVBpVGFncyl7XG5cbiAgICAgICAgfWVsc2V7XG4gIFxuICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IG5ldyB4bWxOb2RlKHRhZ0RhdGEudGFnTmFtZSk7XG4gICAgICAgICAgY2hpbGROb2RlLmFkZCh0aGlzLm9wdGlvbnMudGV4dE5vZGVOYW1lLCBcIlwiKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZih0YWdEYXRhLnRhZ05hbWUgIT09IHRhZ0RhdGEudGFnRXhwICYmIHRhZ0RhdGEuYXR0ckV4cFByZXNlbnQpe1xuICAgICAgICAgICAgY2hpbGROb2RlW1wiOkBcIl0gPSB0aGlzLmJ1aWxkQXR0cmlidXRlc01hcCh0YWdEYXRhLnRhZ0V4cCwgalBhdGgsIHRhZ0RhdGEudGFnTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYWRkQ2hpbGQoY3VycmVudE5vZGUsIGNoaWxkTm9kZSwgalBhdGgpXG5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgaSA9IHRhZ0RhdGEuY2xvc2VJbmRleCArIDE7XG4gICAgICB9IGVsc2UgaWYoeG1sRGF0YS5zdWJzdHIoaSArIDEsIDMpID09PSAnIS0tJykge1xuICAgICAgICBjb25zdCBlbmRJbmRleCA9IGZpbmRDbG9zaW5nSW5kZXgoeG1sRGF0YSwgXCItLT5cIiwgaSs0LCBcIkNvbW1lbnQgaXMgbm90IGNsb3NlZC5cIilcbiAgICAgICAgaWYodGhpcy5vcHRpb25zLmNvbW1lbnRQcm9wTmFtZSl7XG4gICAgICAgICAgY29uc3QgY29tbWVudCA9IHhtbERhdGEuc3Vic3RyaW5nKGkgKyA0LCBlbmRJbmRleCAtIDIpO1xuXG4gICAgICAgICAgdGV4dERhdGEgPSB0aGlzLnNhdmVUZXh0VG9QYXJlbnRUYWcodGV4dERhdGEsIGN1cnJlbnROb2RlLCBqUGF0aCk7XG5cbiAgICAgICAgICBjdXJyZW50Tm9kZS5hZGQodGhpcy5vcHRpb25zLmNvbW1lbnRQcm9wTmFtZSwgWyB7IFt0aGlzLm9wdGlvbnMudGV4dE5vZGVOYW1lXSA6IGNvbW1lbnQgfSBdKTtcbiAgICAgICAgfVxuICAgICAgICBpID0gZW5kSW5kZXg7XG4gICAgICB9IGVsc2UgaWYoIHhtbERhdGEuc3Vic3RyKGkgKyAxLCAyKSA9PT0gJyFEJykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZWFkRG9jVHlwZSh4bWxEYXRhLCBpKTtcbiAgICAgICAgdGhpcy5kb2NUeXBlRW50aXRpZXMgPSByZXN1bHQuZW50aXRpZXM7XG4gICAgICAgIGkgPSByZXN1bHQuaTtcbiAgICAgIH1lbHNlIGlmKHhtbERhdGEuc3Vic3RyKGkgKyAxLCAyKSA9PT0gJyFbJykge1xuICAgICAgICBjb25zdCBjbG9zZUluZGV4ID0gZmluZENsb3NpbmdJbmRleCh4bWxEYXRhLCBcIl1dPlwiLCBpLCBcIkNEQVRBIGlzIG5vdCBjbG9zZWQuXCIpIC0gMjtcbiAgICAgICAgY29uc3QgdGFnRXhwID0geG1sRGF0YS5zdWJzdHJpbmcoaSArIDksY2xvc2VJbmRleCk7XG5cbiAgICAgICAgdGV4dERhdGEgPSB0aGlzLnNhdmVUZXh0VG9QYXJlbnRUYWcodGV4dERhdGEsIGN1cnJlbnROb2RlLCBqUGF0aCk7XG5cbiAgICAgICAgLy9jZGF0YSBzaG91bGQgYmUgc2V0IGV2ZW4gaWYgaXQgaXMgMCBsZW5ndGggc3RyaW5nXG4gICAgICAgIGlmKHRoaXMub3B0aW9ucy5jZGF0YVByb3BOYW1lKXtcbiAgICAgICAgICAvLyBsZXQgdmFsID0gdGhpcy5wYXJzZVRleHREYXRhKHRhZ0V4cCwgdGhpcy5vcHRpb25zLmNkYXRhUHJvcE5hbWUsIGpQYXRoICsgXCIuXCIgKyB0aGlzLm9wdGlvbnMuY2RhdGFQcm9wTmFtZSwgdHJ1ZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgIC8vIGlmKCF2YWwpIHZhbCA9IFwiXCI7XG4gICAgICAgICAgY3VycmVudE5vZGUuYWRkKHRoaXMub3B0aW9ucy5jZGF0YVByb3BOYW1lLCBbIHsgW3RoaXMub3B0aW9ucy50ZXh0Tm9kZU5hbWVdIDogdGFnRXhwIH0gXSk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGxldCB2YWwgPSB0aGlzLnBhcnNlVGV4dERhdGEodGFnRXhwLCBjdXJyZW50Tm9kZS50YWduYW1lLCBqUGF0aCwgdHJ1ZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgIGlmKHZhbCA9PSB1bmRlZmluZWQpIHZhbCA9IFwiXCI7XG4gICAgICAgICAgY3VycmVudE5vZGUuYWRkKHRoaXMub3B0aW9ucy50ZXh0Tm9kZU5hbWUsIHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGkgPSBjbG9zZUluZGV4ICsgMjtcbiAgICAgIH1lbHNlIHsvL09wZW5pbmcgdGFnXG4gICAgICAgIGxldCByZXN1bHQgPSByZWFkVGFnRXhwKHhtbERhdGEsaSwgdGhpcy5vcHRpb25zLnJlbW92ZU5TUHJlZml4KTtcbiAgICAgICAgbGV0IHRhZ05hbWU9IHJlc3VsdC50YWdOYW1lO1xuICAgICAgICBjb25zdCByYXdUYWdOYW1lID0gcmVzdWx0LnJhd1RhZ05hbWU7XG4gICAgICAgIGxldCB0YWdFeHAgPSByZXN1bHQudGFnRXhwO1xuICAgICAgICBsZXQgYXR0ckV4cFByZXNlbnQgPSByZXN1bHQuYXR0ckV4cFByZXNlbnQ7XG4gICAgICAgIGxldCBjbG9zZUluZGV4ID0gcmVzdWx0LmNsb3NlSW5kZXg7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFuc2Zvcm1UYWdOYW1lKSB7XG4gICAgICAgICAgdGFnTmFtZSA9IHRoaXMub3B0aW9ucy50cmFuc2Zvcm1UYWdOYW1lKHRhZ05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvL3NhdmUgdGV4dCBhcyBjaGlsZCBub2RlXG4gICAgICAgIGlmIChjdXJyZW50Tm9kZSAmJiB0ZXh0RGF0YSkge1xuICAgICAgICAgIGlmKGN1cnJlbnROb2RlLnRhZ25hbWUgIT09ICcheG1sJyl7XG4gICAgICAgICAgICAvL3doZW4gbmVzdGVkIHRhZyBpcyBmb3VuZFxuICAgICAgICAgICAgdGV4dERhdGEgPSB0aGlzLnNhdmVUZXh0VG9QYXJlbnRUYWcodGV4dERhdGEsIGN1cnJlbnROb2RlLCBqUGF0aCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hlY2sgaWYgbGFzdCB0YWcgd2FzIHVucGFpcmVkIHRhZ1xuICAgICAgICBjb25zdCBsYXN0VGFnID0gY3VycmVudE5vZGU7XG4gICAgICAgIGlmKGxhc3RUYWcgJiYgdGhpcy5vcHRpb25zLnVucGFpcmVkVGFncy5pbmRleE9mKGxhc3RUYWcudGFnbmFtZSkgIT09IC0xICl7XG4gICAgICAgICAgY3VycmVudE5vZGUgPSB0aGlzLnRhZ3NOb2RlU3RhY2sucG9wKCk7XG4gICAgICAgICAgalBhdGggPSBqUGF0aC5zdWJzdHJpbmcoMCwgalBhdGgubGFzdEluZGV4T2YoXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZih0YWdOYW1lICE9PSB4bWxPYmoudGFnbmFtZSl7XG4gICAgICAgICAgalBhdGggKz0galBhdGggPyBcIi5cIiArIHRhZ05hbWUgOiB0YWdOYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzSXRTdG9wTm9kZSh0aGlzLm9wdGlvbnMuc3RvcE5vZGVzLCBqUGF0aCwgdGFnTmFtZSkpIHtcbiAgICAgICAgICBsZXQgdGFnQ29udGVudCA9IFwiXCI7XG4gICAgICAgICAgLy9zZWxmLWNsb3NpbmcgdGFnXG4gICAgICAgICAgaWYodGFnRXhwLmxlbmd0aCA+IDAgJiYgdGFnRXhwLmxhc3RJbmRleE9mKFwiL1wiKSA9PT0gdGFnRXhwLmxlbmd0aCAtIDEpe1xuICAgICAgICAgICAgaSA9IHJlc3VsdC5jbG9zZUluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL3VucGFpcmVkIHRhZ1xuICAgICAgICAgIGVsc2UgaWYodGhpcy5vcHRpb25zLnVucGFpcmVkVGFncy5pbmRleE9mKHRhZ05hbWUpICE9PSAtMSl7XG4gICAgICAgICAgICBpID0gcmVzdWx0LmNsb3NlSW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vbm9ybWFsIHRhZ1xuICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAvL3JlYWQgdW50aWwgY2xvc2luZyB0YWcgaXMgZm91bmRcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVhZFN0b3BOb2RlRGF0YSh4bWxEYXRhLCByYXdUYWdOYW1lLCBjbG9zZUluZGV4ICsgMSk7XG4gICAgICAgICAgICBpZighcmVzdWx0KSB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgZW5kIG9mICR7cmF3VGFnTmFtZX1gKTtcbiAgICAgICAgICAgIGkgPSByZXN1bHQuaTtcbiAgICAgICAgICAgIHRhZ0NvbnRlbnQgPSByZXN1bHQudGFnQ29udGVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBuZXcgeG1sTm9kZSh0YWdOYW1lKTtcbiAgICAgICAgICBpZih0YWdOYW1lICE9PSB0YWdFeHAgJiYgYXR0ckV4cFByZXNlbnQpe1xuICAgICAgICAgICAgY2hpbGROb2RlW1wiOkBcIl0gPSB0aGlzLmJ1aWxkQXR0cmlidXRlc01hcCh0YWdFeHAsIGpQYXRoLCB0YWdOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYodGFnQ29udGVudCkge1xuICAgICAgICAgICAgdGFnQ29udGVudCA9IHRoaXMucGFyc2VUZXh0RGF0YSh0YWdDb250ZW50LCB0YWdOYW1lLCBqUGF0aCwgdHJ1ZSwgYXR0ckV4cFByZXNlbnQsIHRydWUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBqUGF0aCA9IGpQYXRoLnN1YnN0cigwLCBqUGF0aC5sYXN0SW5kZXhPZihcIi5cIikpO1xuICAgICAgICAgIGNoaWxkTm9kZS5hZGQodGhpcy5vcHRpb25zLnRleHROb2RlTmFtZSwgdGFnQ29udGVudCk7XG4gICAgICAgICAgXG4gICAgICAgICAgdGhpcy5hZGRDaGlsZChjdXJyZW50Tm9kZSwgY2hpbGROb2RlLCBqUGF0aClcbiAgICAgICAgfWVsc2V7XG4gIC8vc2VsZkNsb3NpbmcgdGFnXG4gICAgICAgICAgaWYodGFnRXhwLmxlbmd0aCA+IDAgJiYgdGFnRXhwLmxhc3RJbmRleE9mKFwiL1wiKSA9PT0gdGFnRXhwLmxlbmd0aCAtIDEpe1xuICAgICAgICAgICAgaWYodGFnTmFtZVt0YWdOYW1lLmxlbmd0aCAtIDFdID09PSBcIi9cIil7IC8vcmVtb3ZlIHRyYWlsaW5nICcvJ1xuICAgICAgICAgICAgICB0YWdOYW1lID0gdGFnTmFtZS5zdWJzdHIoMCwgdGFnTmFtZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgalBhdGggPSBqUGF0aC5zdWJzdHIoMCwgalBhdGgubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgIHRhZ0V4cCA9IHRhZ05hbWU7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgdGFnRXhwID0gdGFnRXhwLnN1YnN0cigwLCB0YWdFeHAubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy50cmFuc2Zvcm1UYWdOYW1lKSB7XG4gICAgICAgICAgICAgIHRhZ05hbWUgPSB0aGlzLm9wdGlvbnMudHJhbnNmb3JtVGFnTmFtZSh0YWdOYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlID0gbmV3IHhtbE5vZGUodGFnTmFtZSk7XG4gICAgICAgICAgICBpZih0YWdOYW1lICE9PSB0YWdFeHAgJiYgYXR0ckV4cFByZXNlbnQpe1xuICAgICAgICAgICAgICBjaGlsZE5vZGVbXCI6QFwiXSA9IHRoaXMuYnVpbGRBdHRyaWJ1dGVzTWFwKHRhZ0V4cCwgalBhdGgsIHRhZ05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZGRDaGlsZChjdXJyZW50Tm9kZSwgY2hpbGROb2RlLCBqUGF0aClcbiAgICAgICAgICAgIGpQYXRoID0galBhdGguc3Vic3RyKDAsIGpQYXRoLmxhc3RJbmRleE9mKFwiLlwiKSk7XG4gICAgICAgICAgfVxuICAgIC8vb3BlbmluZyB0YWdcbiAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlID0gbmV3IHhtbE5vZGUoIHRhZ05hbWUpO1xuICAgICAgICAgICAgdGhpcy50YWdzTm9kZVN0YWNrLnB1c2goY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZih0YWdOYW1lICE9PSB0YWdFeHAgJiYgYXR0ckV4cFByZXNlbnQpe1xuICAgICAgICAgICAgICBjaGlsZE5vZGVbXCI6QFwiXSA9IHRoaXMuYnVpbGRBdHRyaWJ1dGVzTWFwKHRhZ0V4cCwgalBhdGgsIHRhZ05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZGRDaGlsZChjdXJyZW50Tm9kZSwgY2hpbGROb2RlLCBqUGF0aClcbiAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY2hpbGROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ZXh0RGF0YSA9IFwiXCI7XG4gICAgICAgICAgaSA9IGNsb3NlSW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9ZWxzZXtcbiAgICAgIHRleHREYXRhICs9IHhtbERhdGFbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiB4bWxPYmouY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIGFkZENoaWxkKGN1cnJlbnROb2RlLCBjaGlsZE5vZGUsIGpQYXRoKXtcbiAgY29uc3QgcmVzdWx0ID0gdGhpcy5vcHRpb25zLnVwZGF0ZVRhZyhjaGlsZE5vZGUudGFnbmFtZSwgalBhdGgsIGNoaWxkTm9kZVtcIjpAXCJdKVxuICBpZihyZXN1bHQgPT09IGZhbHNlKXtcbiAgfWVsc2UgaWYodHlwZW9mIHJlc3VsdCA9PT0gXCJzdHJpbmdcIil7XG4gICAgY2hpbGROb2RlLnRhZ25hbWUgPSByZXN1bHRcbiAgICBjdXJyZW50Tm9kZS5hZGRDaGlsZChjaGlsZE5vZGUpO1xuICB9ZWxzZXtcbiAgICBjdXJyZW50Tm9kZS5hZGRDaGlsZChjaGlsZE5vZGUpO1xuICB9XG59XG5cbmNvbnN0IHJlcGxhY2VFbnRpdGllc1ZhbHVlID0gZnVuY3Rpb24odmFsKXtcblxuICBpZih0aGlzLm9wdGlvbnMucHJvY2Vzc0VudGl0aWVzKXtcbiAgICBmb3IobGV0IGVudGl0eU5hbWUgaW4gdGhpcy5kb2NUeXBlRW50aXRpZXMpe1xuICAgICAgY29uc3QgZW50aXR5ID0gdGhpcy5kb2NUeXBlRW50aXRpZXNbZW50aXR5TmFtZV07XG4gICAgICB2YWwgPSB2YWwucmVwbGFjZSggZW50aXR5LnJlZ3gsIGVudGl0eS52YWwpO1xuICAgIH1cbiAgICBmb3IobGV0IGVudGl0eU5hbWUgaW4gdGhpcy5sYXN0RW50aXRpZXMpe1xuICAgICAgY29uc3QgZW50aXR5ID0gdGhpcy5sYXN0RW50aXRpZXNbZW50aXR5TmFtZV07XG4gICAgICB2YWwgPSB2YWwucmVwbGFjZSggZW50aXR5LnJlZ2V4LCBlbnRpdHkudmFsKTtcbiAgICB9XG4gICAgaWYodGhpcy5vcHRpb25zLmh0bWxFbnRpdGllcyl7XG4gICAgICBmb3IobGV0IGVudGl0eU5hbWUgaW4gdGhpcy5odG1sRW50aXRpZXMpe1xuICAgICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmh0bWxFbnRpdGllc1tlbnRpdHlOYW1lXTtcbiAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoIGVudGl0eS5yZWdleCwgZW50aXR5LnZhbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhbCA9IHZhbC5yZXBsYWNlKCB0aGlzLmFtcEVudGl0eS5yZWdleCwgdGhpcy5hbXBFbnRpdHkudmFsKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gc2F2ZVRleHRUb1BhcmVudFRhZyh0ZXh0RGF0YSwgY3VycmVudE5vZGUsIGpQYXRoLCBpc0xlYWZOb2RlKSB7XG4gIGlmICh0ZXh0RGF0YSkgeyAvL3N0b3JlIHByZXZpb3VzbHkgY29sbGVjdGVkIGRhdGEgYXMgdGV4dE5vZGVcbiAgICBpZihpc0xlYWZOb2RlID09PSB1bmRlZmluZWQpIGlzTGVhZk5vZGUgPSBPYmplY3Qua2V5cyhjdXJyZW50Tm9kZS5jaGlsZCkubGVuZ3RoID09PSAwXG4gICAgXG4gICAgdGV4dERhdGEgPSB0aGlzLnBhcnNlVGV4dERhdGEodGV4dERhdGEsXG4gICAgICBjdXJyZW50Tm9kZS50YWduYW1lLFxuICAgICAgalBhdGgsXG4gICAgICBmYWxzZSxcbiAgICAgIGN1cnJlbnROb2RlW1wiOkBcIl0gPyBPYmplY3Qua2V5cyhjdXJyZW50Tm9kZVtcIjpAXCJdKS5sZW5ndGggIT09IDAgOiBmYWxzZSxcbiAgICAgIGlzTGVhZk5vZGUpO1xuXG4gICAgaWYgKHRleHREYXRhICE9PSB1bmRlZmluZWQgJiYgdGV4dERhdGEgIT09IFwiXCIpXG4gICAgICBjdXJyZW50Tm9kZS5hZGQodGhpcy5vcHRpb25zLnRleHROb2RlTmFtZSwgdGV4dERhdGEpO1xuICAgIHRleHREYXRhID0gXCJcIjtcbiAgfVxuICByZXR1cm4gdGV4dERhdGE7XG59XG5cbi8vVE9ETzogdXNlIGpQYXRoIHRvIHNpbXBsaWZ5IHRoZSBsb2dpY1xuLyoqXG4gKiBcbiAqIEBwYXJhbSB7c3RyaW5nW119IHN0b3BOb2RlcyBcbiAqIEBwYXJhbSB7c3RyaW5nfSBqUGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IGN1cnJlbnRUYWdOYW1lIFxuICovXG5mdW5jdGlvbiBpc0l0U3RvcE5vZGUoc3RvcE5vZGVzLCBqUGF0aCwgY3VycmVudFRhZ05hbWUpe1xuICBjb25zdCBhbGxOb2Rlc0V4cCA9IFwiKi5cIiArIGN1cnJlbnRUYWdOYW1lO1xuICBmb3IgKGNvbnN0IHN0b3BOb2RlUGF0aCBpbiBzdG9wTm9kZXMpIHtcbiAgICBjb25zdCBzdG9wTm9kZUV4cCA9IHN0b3BOb2Rlc1tzdG9wTm9kZVBhdGhdO1xuICAgIGlmKCBhbGxOb2Rlc0V4cCA9PT0gc3RvcE5vZGVFeHAgfHwgalBhdGggPT09IHN0b3BOb2RlRXhwICApIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0YWcgRXhwcmVzc2lvbiBhbmQgd2hlcmUgaXQgaXMgZW5kaW5nIGhhbmRsaW5nIHNpbmdsZS1kb3VibGUgcXVvdGVzIHNpdHVhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHhtbERhdGEgXG4gKiBAcGFyYW0ge251bWJlcn0gaSBzdGFydGluZyBpbmRleFxuICogQHJldHVybnMgXG4gKi9cbmZ1bmN0aW9uIHRhZ0V4cFdpdGhDbG9zaW5nSW5kZXgoeG1sRGF0YSwgaSwgY2xvc2luZ0NoYXIgPSBcIj5cIil7XG4gIGxldCBhdHRyQm91bmRhcnk7XG4gIGxldCB0YWdFeHAgPSBcIlwiO1xuICBmb3IgKGxldCBpbmRleCA9IGk7IGluZGV4IDwgeG1sRGF0YS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBsZXQgY2ggPSB4bWxEYXRhW2luZGV4XTtcbiAgICBpZiAoYXR0ckJvdW5kYXJ5KSB7XG4gICAgICAgIGlmIChjaCA9PT0gYXR0ckJvdW5kYXJ5KSBhdHRyQm91bmRhcnkgPSBcIlwiOy8vcmVzZXRcbiAgICB9IGVsc2UgaWYgKGNoID09PSAnXCInIHx8IGNoID09PSBcIidcIikge1xuICAgICAgICBhdHRyQm91bmRhcnkgPSBjaDtcbiAgICB9IGVsc2UgaWYgKGNoID09PSBjbG9zaW5nQ2hhclswXSkge1xuICAgICAgaWYoY2xvc2luZ0NoYXJbMV0pe1xuICAgICAgICBpZih4bWxEYXRhW2luZGV4ICsgMV0gPT09IGNsb3NpbmdDaGFyWzFdKXtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogdGFnRXhwLFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9ZWxzZXtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB0YWdFeHAsXG4gICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoID09PSAnXFx0Jykge1xuICAgICAgY2ggPSBcIiBcIlxuICAgIH1cbiAgICB0YWdFeHAgKz0gY2g7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZENsb3NpbmdJbmRleCh4bWxEYXRhLCBzdHIsIGksIGVyck1zZyl7XG4gIGNvbnN0IGNsb3NpbmdJbmRleCA9IHhtbERhdGEuaW5kZXhPZihzdHIsIGkpO1xuICBpZihjbG9zaW5nSW5kZXggPT09IC0xKXtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKVxuICB9ZWxzZXtcbiAgICByZXR1cm4gY2xvc2luZ0luZGV4ICsgc3RyLmxlbmd0aCAtIDE7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhZFRhZ0V4cCh4bWxEYXRhLGksIHJlbW92ZU5TUHJlZml4LCBjbG9zaW5nQ2hhciA9IFwiPlwiKXtcbiAgY29uc3QgcmVzdWx0ID0gdGFnRXhwV2l0aENsb3NpbmdJbmRleCh4bWxEYXRhLCBpKzEsIGNsb3NpbmdDaGFyKTtcbiAgaWYoIXJlc3VsdCkgcmV0dXJuO1xuICBsZXQgdGFnRXhwID0gcmVzdWx0LmRhdGE7XG4gIGNvbnN0IGNsb3NlSW5kZXggPSByZXN1bHQuaW5kZXg7XG4gIGNvbnN0IHNlcGFyYXRvckluZGV4ID0gdGFnRXhwLnNlYXJjaCgvXFxzLyk7XG4gIGxldCB0YWdOYW1lID0gdGFnRXhwO1xuICBsZXQgYXR0ckV4cFByZXNlbnQgPSB0cnVlO1xuICBpZihzZXBhcmF0b3JJbmRleCAhPT0gLTEpey8vc2VwYXJhdGUgdGFnIG5hbWUgYW5kIGF0dHJpYnV0ZXMgZXhwcmVzc2lvblxuICAgIHRhZ05hbWUgPSB0YWdFeHAuc3Vic3RyKDAsIHNlcGFyYXRvckluZGV4KS5yZXBsYWNlKC9cXHNcXHMqJC8sICcnKTtcbiAgICB0YWdFeHAgPSB0YWdFeHAuc3Vic3RyKHNlcGFyYXRvckluZGV4ICsgMSk7XG4gIH1cblxuICBjb25zdCByYXdUYWdOYW1lID0gdGFnTmFtZTtcbiAgaWYocmVtb3ZlTlNQcmVmaXgpe1xuICAgIGNvbnN0IGNvbG9uSW5kZXggPSB0YWdOYW1lLmluZGV4T2YoXCI6XCIpO1xuICAgIGlmKGNvbG9uSW5kZXggIT09IC0xKXtcbiAgICAgIHRhZ05hbWUgPSB0YWdOYW1lLnN1YnN0cihjb2xvbkluZGV4KzEpO1xuICAgICAgYXR0ckV4cFByZXNlbnQgPSB0YWdOYW1lICE9PSByZXN1bHQuZGF0YS5zdWJzdHIoY29sb25JbmRleCArIDEpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdGFnTmFtZTogdGFnTmFtZSxcbiAgICB0YWdFeHA6IHRhZ0V4cCxcbiAgICBjbG9zZUluZGV4OiBjbG9zZUluZGV4LFxuICAgIGF0dHJFeHBQcmVzZW50OiBhdHRyRXhwUHJlc2VudCxcbiAgICByYXdUYWdOYW1lOiByYXdUYWdOYW1lLFxuICB9XG59XG4vKipcbiAqIGZpbmQgcGFpcmVkIHRhZyBmb3IgYSBzdG9wIG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB4bWxEYXRhIFxuICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgXG4gKiBAcGFyYW0ge251bWJlcn0gaSBcbiAqL1xuZnVuY3Rpb24gcmVhZFN0b3BOb2RlRGF0YSh4bWxEYXRhLCB0YWdOYW1lLCBpKXtcbiAgY29uc3Qgc3RhcnRJbmRleCA9IGk7XG4gIC8vIFN0YXJ0aW5nIGF0IDEgc2luY2Ugd2UgYWxyZWFkeSBoYXZlIGFuIG9wZW4gdGFnXG4gIGxldCBvcGVuVGFnQ291bnQgPSAxO1xuXG4gIGZvciAoOyBpIDwgeG1sRGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGlmKCB4bWxEYXRhW2ldID09PSBcIjxcIil7IFxuICAgICAgaWYgKHhtbERhdGFbaSsxXSA9PT0gXCIvXCIpIHsvL2Nsb3NlIHRhZ1xuICAgICAgICAgIGNvbnN0IGNsb3NlSW5kZXggPSBmaW5kQ2xvc2luZ0luZGV4KHhtbERhdGEsIFwiPlwiLCBpLCBgJHt0YWdOYW1lfSBpcyBub3QgY2xvc2VkYCk7XG4gICAgICAgICAgbGV0IGNsb3NlVGFnTmFtZSA9IHhtbERhdGEuc3Vic3RyaW5nKGkrMixjbG9zZUluZGV4KS50cmltKCk7XG4gICAgICAgICAgaWYoY2xvc2VUYWdOYW1lID09PSB0YWdOYW1lKXtcbiAgICAgICAgICAgIG9wZW5UYWdDb3VudC0tO1xuICAgICAgICAgICAgaWYgKG9wZW5UYWdDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRhZ0NvbnRlbnQ6IHhtbERhdGEuc3Vic3RyaW5nKHN0YXJ0SW5kZXgsIGkpLFxuICAgICAgICAgICAgICAgIGkgOiBjbG9zZUluZGV4XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaT1jbG9zZUluZGV4O1xuICAgICAgICB9IGVsc2UgaWYoeG1sRGF0YVtpKzFdID09PSAnPycpIHsgXG4gICAgICAgICAgY29uc3QgY2xvc2VJbmRleCA9IGZpbmRDbG9zaW5nSW5kZXgoeG1sRGF0YSwgXCI/PlwiLCBpKzEsIFwiU3RvcE5vZGUgaXMgbm90IGNsb3NlZC5cIilcbiAgICAgICAgICBpPWNsb3NlSW5kZXg7XG4gICAgICAgIH0gZWxzZSBpZih4bWxEYXRhLnN1YnN0cihpICsgMSwgMykgPT09ICchLS0nKSB7IFxuICAgICAgICAgIGNvbnN0IGNsb3NlSW5kZXggPSBmaW5kQ2xvc2luZ0luZGV4KHhtbERhdGEsIFwiLS0+XCIsIGkrMywgXCJTdG9wTm9kZSBpcyBub3QgY2xvc2VkLlwiKVxuICAgICAgICAgIGk9Y2xvc2VJbmRleDtcbiAgICAgICAgfSBlbHNlIGlmKHhtbERhdGEuc3Vic3RyKGkgKyAxLCAyKSA9PT0gJyFbJykgeyBcbiAgICAgICAgICBjb25zdCBjbG9zZUluZGV4ID0gZmluZENsb3NpbmdJbmRleCh4bWxEYXRhLCBcIl1dPlwiLCBpLCBcIlN0b3BOb2RlIGlzIG5vdCBjbG9zZWQuXCIpIC0gMjtcbiAgICAgICAgICBpPWNsb3NlSW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdGFnRGF0YSA9IHJlYWRUYWdFeHAoeG1sRGF0YSwgaSwgJz4nKVxuXG4gICAgICAgICAgaWYgKHRhZ0RhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wZW5UYWdOYW1lID0gdGFnRGF0YSAmJiB0YWdEYXRhLnRhZ05hbWU7XG4gICAgICAgICAgICBpZiAob3BlblRhZ05hbWUgPT09IHRhZ05hbWUgJiYgdGFnRGF0YS50YWdFeHBbdGFnRGF0YS50YWdFeHAubGVuZ3RoLTFdICE9PSBcIi9cIikge1xuICAgICAgICAgICAgICBvcGVuVGFnQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGk9dGFnRGF0YS5jbG9zZUluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICB9Ly9lbmQgZm9yIGxvb3Bcbn1cblxuZnVuY3Rpb24gcGFyc2VWYWx1ZSh2YWwsIHNob3VsZFBhcnNlLCBvcHRpb25zKSB7XG4gIGlmIChzaG91bGRQYXJzZSAmJiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIC8vY29uc29sZS5sb2cob3B0aW9ucylcbiAgICBjb25zdCBuZXd2YWwgPSB2YWwudHJpbSgpO1xuICAgIGlmKG5ld3ZhbCA9PT0gJ3RydWUnICkgcmV0dXJuIHRydWU7XG4gICAgZWxzZSBpZihuZXd2YWwgPT09ICdmYWxzZScgKSByZXR1cm4gZmFsc2U7XG4gICAgZWxzZSByZXR1cm4gdG9OdW1iZXIodmFsLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodXRpbC5pc0V4aXN0KHZhbCkpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IE9yZGVyZWRPYmpQYXJzZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/fast-xml-parser/src/xmlparser/XMLParser.js":
/*!*****************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/XMLParser.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { buildOptions} = __webpack_require__(/*! ./OptionsBuilder */ \"(ssr)/./node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js\");\nconst OrderedObjParser = __webpack_require__(/*! ./OrderedObjParser */ \"(ssr)/./node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js\");\nconst { prettify} = __webpack_require__(/*! ./node2json */ \"(ssr)/./node_modules/fast-xml-parser/src/xmlparser/node2json.js\");\nconst validator = __webpack_require__(/*! ../validator */ \"(ssr)/./node_modules/fast-xml-parser/src/validator.js\");\n\nclass XMLParser{\n    \n    constructor(options){\n        this.externalEntities = {};\n        this.options = buildOptions(options);\n        \n    }\n    /**\n     * Parse XML dats to JS object \n     * @param {string|Buffer} xmlData \n     * @param {boolean|Object} validationOption \n     */\n    parse(xmlData,validationOption){\n        if(typeof xmlData === \"string\"){\n        }else if( xmlData.toString){\n            xmlData = xmlData.toString();\n        }else{\n            throw new Error(\"XML data is accepted in String or Bytes[] form.\")\n        }\n        if( validationOption){\n            if(validationOption === true) validationOption = {}; //validate with default options\n            \n            const result = validator.validate(xmlData, validationOption);\n            if (result !== true) {\n              throw Error( `${result.err.msg}:${result.err.line}:${result.err.col}` )\n            }\n          }\n        const orderedObjParser = new OrderedObjParser(this.options);\n        orderedObjParser.addExternalEntities(this.externalEntities);\n        const orderedResult = orderedObjParser.parseXml(xmlData);\n        if(this.options.preserveOrder || orderedResult === undefined) return orderedResult;\n        else return prettify(orderedResult, this.options);\n    }\n\n    /**\n     * Add Entity which is not by default supported by this library\n     * @param {string} key \n     * @param {string} value \n     */\n    addEntity(key, value){\n        if(value.indexOf(\"&\") !== -1){\n            throw new Error(\"Entity value can't have '&'\")\n        }else if(key.indexOf(\"&\") !== -1 || key.indexOf(\";\") !== -1){\n            throw new Error(\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\")\n        }else if(value === \"&\"){\n            throw new Error(\"An entity with value '&' is not permitted\");\n        }else{\n            this.externalEntities[key] = value;\n        }\n    }\n}\n\nmodule.exports = XMLParser;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvWE1MUGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBLFFBQVEsY0FBYyxFQUFFLG1CQUFPLENBQUMsOEZBQWtCO0FBQ2xELHlCQUF5QixtQkFBTyxDQUFDLGtHQUFvQjtBQUNyRCxRQUFRLFVBQVUsRUFBRSxtQkFBTyxDQUFDLG9GQUFhO0FBQ3pDLGtCQUFrQixtQkFBTyxDQUFDLDJFQUFjOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZUFBZSxHQUFHLGdCQUFnQixHQUFHLGVBQWU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaURBQWlEO0FBQzFELHFFQUFxRSwyQkFBMkI7QUFDaEcsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGlhcnktZnJvbnQtZW5kLy4vbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMveG1scGFyc2VyL1hNTFBhcnNlci5qcz9hMjdhIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgYnVpbGRPcHRpb25zfSA9IHJlcXVpcmUoXCIuL09wdGlvbnNCdWlsZGVyXCIpO1xuY29uc3QgT3JkZXJlZE9ialBhcnNlciA9IHJlcXVpcmUoXCIuL09yZGVyZWRPYmpQYXJzZXJcIik7XG5jb25zdCB7IHByZXR0aWZ5fSA9IHJlcXVpcmUoXCIuL25vZGUyanNvblwiKTtcbmNvbnN0IHZhbGlkYXRvciA9IHJlcXVpcmUoJy4uL3ZhbGlkYXRvcicpO1xuXG5jbGFzcyBYTUxQYXJzZXJ7XG4gICAgXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyl7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxFbnRpdGllcyA9IHt9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBidWlsZE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBYTUwgZGF0cyB0byBKUyBvYmplY3QgXG4gICAgICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSB4bWxEYXRhIFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9IHZhbGlkYXRpb25PcHRpb24gXG4gICAgICovXG4gICAgcGFyc2UoeG1sRGF0YSx2YWxpZGF0aW9uT3B0aW9uKXtcbiAgICAgICAgaWYodHlwZW9mIHhtbERhdGEgPT09IFwic3RyaW5nXCIpe1xuICAgICAgICB9ZWxzZSBpZiggeG1sRGF0YS50b1N0cmluZyl7XG4gICAgICAgICAgICB4bWxEYXRhID0geG1sRGF0YS50b1N0cmluZygpO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlhNTCBkYXRhIGlzIGFjY2VwdGVkIGluIFN0cmluZyBvciBCeXRlc1tdIGZvcm0uXCIpXG4gICAgICAgIH1cbiAgICAgICAgaWYoIHZhbGlkYXRpb25PcHRpb24pe1xuICAgICAgICAgICAgaWYodmFsaWRhdGlvbk9wdGlvbiA9PT0gdHJ1ZSkgdmFsaWRhdGlvbk9wdGlvbiA9IHt9OyAvL3ZhbGlkYXRlIHdpdGggZGVmYXVsdCBvcHRpb25zXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRvci52YWxpZGF0ZSh4bWxEYXRhLCB2YWxpZGF0aW9uT3B0aW9uKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIGAke3Jlc3VsdC5lcnIubXNnfToke3Jlc3VsdC5lcnIubGluZX06JHtyZXN1bHQuZXJyLmNvbH1gIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9yZGVyZWRPYmpQYXJzZXIgPSBuZXcgT3JkZXJlZE9ialBhcnNlcih0aGlzLm9wdGlvbnMpO1xuICAgICAgICBvcmRlcmVkT2JqUGFyc2VyLmFkZEV4dGVybmFsRW50aXRpZXModGhpcy5leHRlcm5hbEVudGl0aWVzKTtcbiAgICAgICAgY29uc3Qgb3JkZXJlZFJlc3VsdCA9IG9yZGVyZWRPYmpQYXJzZXIucGFyc2VYbWwoeG1sRGF0YSk7XG4gICAgICAgIGlmKHRoaXMub3B0aW9ucy5wcmVzZXJ2ZU9yZGVyIHx8IG9yZGVyZWRSZXN1bHQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG9yZGVyZWRSZXN1bHQ7XG4gICAgICAgIGVsc2UgcmV0dXJuIHByZXR0aWZ5KG9yZGVyZWRSZXN1bHQsIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIEVudGl0eSB3aGljaCBpcyBub3QgYnkgZGVmYXVsdCBzdXBwb3J0ZWQgYnkgdGhpcyBsaWJyYXJ5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgXG4gICAgICovXG4gICAgYWRkRW50aXR5KGtleSwgdmFsdWUpe1xuICAgICAgICBpZih2YWx1ZS5pbmRleE9mKFwiJlwiKSAhPT0gLTEpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW50aXR5IHZhbHVlIGNhbid0IGhhdmUgJyYnXCIpXG4gICAgICAgIH1lbHNlIGlmKGtleS5pbmRleE9mKFwiJlwiKSAhPT0gLTEgfHwga2V5LmluZGV4T2YoXCI7XCIpICE9PSAtMSl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbiBlbnRpdHkgbXVzdCBiZSBzZXQgd2l0aG91dCAnJicgYW5kICc7Jy4gRWcuIHVzZSAnI3hEJyBmb3IgJyYjeEQ7J1wiKVxuICAgICAgICB9ZWxzZSBpZih2YWx1ZSA9PT0gXCImXCIpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW4gZW50aXR5IHdpdGggdmFsdWUgJyYnIGlzIG5vdCBwZXJtaXR0ZWRcIik7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhpcy5leHRlcm5hbEVudGl0aWVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBYTUxQYXJzZXI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-xml-parser/src/xmlparser/XMLParser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/fast-xml-parser/src/xmlparser/node2json.js":
/*!*****************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/node2json.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n/**\n * \n * @param {array} node \n * @param {any} options \n * @returns \n */\nfunction prettify(node, options){\n  return compress( node, options);\n}\n\n/**\n * \n * @param {array} arr \n * @param {object} options \n * @param {string} jPath \n * @returns object\n */\nfunction compress(arr, options, jPath){\n  let text;\n  const compressedObj = {};\n  for (let i = 0; i < arr.length; i++) {\n    const tagObj = arr[i];\n    const property = propName(tagObj);\n    let newJpath = \"\";\n    if(jPath === undefined) newJpath = property;\n    else newJpath = jPath + \".\" + property;\n\n    if(property === options.textNodeName){\n      if(text === undefined) text = tagObj[property];\n      else text += \"\" + tagObj[property];\n    }else if(property === undefined){\n      continue;\n    }else if(tagObj[property]){\n      \n      let val = compress(tagObj[property], options, newJpath);\n      const isLeaf = isLeafTag(val, options);\n\n      if(tagObj[\":@\"]){\n        assignAttributes( val, tagObj[\":@\"], newJpath, options);\n      }else if(Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode){\n        val = val[options.textNodeName];\n      }else if(Object.keys(val).length === 0){\n        if(options.alwaysCreateTextNode) val[options.textNodeName] = \"\";\n        else val = \"\";\n      }\n\n      if(compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {\n        if(!Array.isArray(compressedObj[property])) {\n            compressedObj[property] = [ compressedObj[property] ];\n        }\n        compressedObj[property].push(val);\n      }else{\n        //TODO: if a node is not an array, then check if it should be an array\n        //also determine if it is a leaf node\n        if (options.isArray(property, newJpath, isLeaf )) {\n          compressedObj[property] = [val];\n        }else{\n          compressedObj[property] = val;\n        }\n      }\n    }\n    \n  }\n  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;\n  if(typeof text === \"string\"){\n    if(text.length > 0) compressedObj[options.textNodeName] = text;\n  }else if(text !== undefined) compressedObj[options.textNodeName] = text;\n  return compressedObj;\n}\n\nfunction propName(obj){\n  const keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if(key !== \":@\") return key;\n  }\n}\n\nfunction assignAttributes(obj, attrMap, jpath, options){\n  if (attrMap) {\n    const keys = Object.keys(attrMap);\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      const atrrName = keys[i];\n      if (options.isArray(atrrName, jpath + \".\" + atrrName, true, true)) {\n        obj[atrrName] = [ attrMap[atrrName] ];\n      } else {\n        obj[atrrName] = attrMap[atrrName];\n      }\n    }\n  }\n}\n\nfunction isLeafTag(obj, options){\n  const { textNodeName } = options;\n  const propCount = Object.keys(obj).length;\n  \n  if (propCount === 0) {\n    return true;\n  }\n\n  if (\n    propCount === 1 &&\n    (obj[textNodeName] || typeof obj[textNodeName] === \"boolean\" || obj[textNodeName] === 0)\n  ) {\n    return true;\n  }\n\n  return false;\n}\nexports.prettify = prettify;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvbm9kZTJqc29uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsZUFBZTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGlhcnktZnJvbnQtZW5kLy4vbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMveG1scGFyc2VyL25vZGUyanNvbi5qcz9iMTk2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBcbiAqIEBwYXJhbSB7YXJyYXl9IG5vZGUgXG4gKiBAcGFyYW0ge2FueX0gb3B0aW9ucyBcbiAqIEByZXR1cm5zIFxuICovXG5mdW5jdGlvbiBwcmV0dGlmeShub2RlLCBvcHRpb25zKXtcbiAgcmV0dXJuIGNvbXByZXNzKCBub2RlLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBcbiAqIEBwYXJhbSB7YXJyYXl9IGFyciBcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIFxuICogQHBhcmFtIHtzdHJpbmd9IGpQYXRoIFxuICogQHJldHVybnMgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGNvbXByZXNzKGFyciwgb3B0aW9ucywgalBhdGgpe1xuICBsZXQgdGV4dDtcbiAgY29uc3QgY29tcHJlc3NlZE9iaiA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRhZ09iaiA9IGFycltpXTtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IHByb3BOYW1lKHRhZ09iaik7XG4gICAgbGV0IG5ld0pwYXRoID0gXCJcIjtcbiAgICBpZihqUGF0aCA9PT0gdW5kZWZpbmVkKSBuZXdKcGF0aCA9IHByb3BlcnR5O1xuICAgIGVsc2UgbmV3SnBhdGggPSBqUGF0aCArIFwiLlwiICsgcHJvcGVydHk7XG5cbiAgICBpZihwcm9wZXJ0eSA9PT0gb3B0aW9ucy50ZXh0Tm9kZU5hbWUpe1xuICAgICAgaWYodGV4dCA9PT0gdW5kZWZpbmVkKSB0ZXh0ID0gdGFnT2JqW3Byb3BlcnR5XTtcbiAgICAgIGVsc2UgdGV4dCArPSBcIlwiICsgdGFnT2JqW3Byb3BlcnR5XTtcbiAgICB9ZWxzZSBpZihwcm9wZXJ0eSA9PT0gdW5kZWZpbmVkKXtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1lbHNlIGlmKHRhZ09ialtwcm9wZXJ0eV0pe1xuICAgICAgXG4gICAgICBsZXQgdmFsID0gY29tcHJlc3ModGFnT2JqW3Byb3BlcnR5XSwgb3B0aW9ucywgbmV3SnBhdGgpO1xuICAgICAgY29uc3QgaXNMZWFmID0gaXNMZWFmVGFnKHZhbCwgb3B0aW9ucyk7XG5cbiAgICAgIGlmKHRhZ09ialtcIjpAXCJdKXtcbiAgICAgICAgYXNzaWduQXR0cmlidXRlcyggdmFsLCB0YWdPYmpbXCI6QFwiXSwgbmV3SnBhdGgsIG9wdGlvbnMpO1xuICAgICAgfWVsc2UgaWYoT2JqZWN0LmtleXModmFsKS5sZW5ndGggPT09IDEgJiYgdmFsW29wdGlvbnMudGV4dE5vZGVOYW1lXSAhPT0gdW5kZWZpbmVkICYmICFvcHRpb25zLmFsd2F5c0NyZWF0ZVRleHROb2RlKXtcbiAgICAgICAgdmFsID0gdmFsW29wdGlvbnMudGV4dE5vZGVOYW1lXTtcbiAgICAgIH1lbHNlIGlmKE9iamVjdC5rZXlzKHZhbCkubGVuZ3RoID09PSAwKXtcbiAgICAgICAgaWYob3B0aW9ucy5hbHdheXNDcmVhdGVUZXh0Tm9kZSkgdmFsW29wdGlvbnMudGV4dE5vZGVOYW1lXSA9IFwiXCI7XG4gICAgICAgIGVsc2UgdmFsID0gXCJcIjtcbiAgICAgIH1cblxuICAgICAgaWYoY29tcHJlc3NlZE9ialtwcm9wZXJ0eV0gIT09IHVuZGVmaW5lZCAmJiBjb21wcmVzc2VkT2JqLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICBpZighQXJyYXkuaXNBcnJheShjb21wcmVzc2VkT2JqW3Byb3BlcnR5XSkpIHtcbiAgICAgICAgICAgIGNvbXByZXNzZWRPYmpbcHJvcGVydHldID0gWyBjb21wcmVzc2VkT2JqW3Byb3BlcnR5XSBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbXByZXNzZWRPYmpbcHJvcGVydHldLnB1c2godmFsKTtcbiAgICAgIH1lbHNle1xuICAgICAgICAvL1RPRE86IGlmIGEgbm9kZSBpcyBub3QgYW4gYXJyYXksIHRoZW4gY2hlY2sgaWYgaXQgc2hvdWxkIGJlIGFuIGFycmF5XG4gICAgICAgIC8vYWxzbyBkZXRlcm1pbmUgaWYgaXQgaXMgYSBsZWFmIG5vZGVcbiAgICAgICAgaWYgKG9wdGlvbnMuaXNBcnJheShwcm9wZXJ0eSwgbmV3SnBhdGgsIGlzTGVhZiApKSB7XG4gICAgICAgICAgY29tcHJlc3NlZE9ialtwcm9wZXJ0eV0gPSBbdmFsXTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgY29tcHJlc3NlZE9ialtwcm9wZXJ0eV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gIH1cbiAgLy8gaWYodGV4dCAmJiB0ZXh0Lmxlbmd0aCA+IDApIGNvbXByZXNzZWRPYmpbb3B0aW9ucy50ZXh0Tm9kZU5hbWVdID0gdGV4dDtcbiAgaWYodHlwZW9mIHRleHQgPT09IFwic3RyaW5nXCIpe1xuICAgIGlmKHRleHQubGVuZ3RoID4gMCkgY29tcHJlc3NlZE9ialtvcHRpb25zLnRleHROb2RlTmFtZV0gPSB0ZXh0O1xuICB9ZWxzZSBpZih0ZXh0ICE9PSB1bmRlZmluZWQpIGNvbXByZXNzZWRPYmpbb3B0aW9ucy50ZXh0Tm9kZU5hbWVdID0gdGV4dDtcbiAgcmV0dXJuIGNvbXByZXNzZWRPYmo7XG59XG5cbmZ1bmN0aW9uIHByb3BOYW1lKG9iail7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGlmKGtleSAhPT0gXCI6QFwiKSByZXR1cm4ga2V5O1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnbkF0dHJpYnV0ZXMob2JqLCBhdHRyTWFwLCBqcGF0aCwgb3B0aW9ucyl7XG4gIGlmIChhdHRyTWFwKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGF0dHJNYXApO1xuICAgIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoOyAvL2Rvbid0IG1ha2UgaXQgaW5saW5lXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgYXRyck5hbWUgPSBrZXlzW2ldO1xuICAgICAgaWYgKG9wdGlvbnMuaXNBcnJheShhdHJyTmFtZSwganBhdGggKyBcIi5cIiArIGF0cnJOYW1lLCB0cnVlLCB0cnVlKSkge1xuICAgICAgICBvYmpbYXRyck5hbWVdID0gWyBhdHRyTWFwW2F0cnJOYW1lXSBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2F0cnJOYW1lXSA9IGF0dHJNYXBbYXRyck5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0xlYWZUYWcob2JqLCBvcHRpb25zKXtcbiAgY29uc3QgeyB0ZXh0Tm9kZU5hbWUgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHByb3BDb3VudCA9IE9iamVjdC5rZXlzKG9iaikubGVuZ3RoO1xuICBcbiAgaWYgKHByb3BDb3VudCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKFxuICAgIHByb3BDb3VudCA9PT0gMSAmJlxuICAgIChvYmpbdGV4dE5vZGVOYW1lXSB8fCB0eXBlb2Ygb2JqW3RleHROb2RlTmFtZV0gPT09IFwiYm9vbGVhblwiIHx8IG9ialt0ZXh0Tm9kZU5hbWVdID09PSAwKVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMucHJldHRpZnkgPSBwcmV0dGlmeTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-xml-parser/src/xmlparser/node2json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/fast-xml-parser/src/xmlparser/xmlNode.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/xmlNode.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nclass XmlNode{\n  constructor(tagname) {\n    this.tagname = tagname;\n    this.child = []; //nested tags, text, cdata, comments in order\n    this[\":@\"] = {}; //attributes map\n  }\n  add(key,val){\n    // this.child.push( {name : key, val: val, isCdata: isCdata });\n    if(key === \"__proto__\") key = \"#__proto__\";\n    this.child.push( {[key]: val });\n  }\n  addChild(node) {\n    if(node.tagname === \"__proto__\") node.tagname = \"#__proto__\";\n    if(node[\":@\"] && Object.keys(node[\":@\"]).length > 0){\n      this.child.push( { [node.tagname]: node.child, [\":@\"]: node[\":@\"] });\n    }else{\n      this.child.push( { [node.tagname]: node.child });\n    }\n  };\n};\n\n\nmodule.exports = XmlNode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIveG1sTm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSx5QkFBeUIsd0NBQXdDO0FBQ2pFO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0RBQWdEO0FBQ3pFLEtBQUs7QUFDTCx5QkFBeUIsNEJBQTRCO0FBQ3JEO0FBQ0E7QUFDQTs7O0FBR0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kaWFyeS1mcm9udC1lbmQvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIveG1sTm9kZS5qcz83NDM2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY2xhc3MgWG1sTm9kZXtcbiAgY29uc3RydWN0b3IodGFnbmFtZSkge1xuICAgIHRoaXMudGFnbmFtZSA9IHRhZ25hbWU7XG4gICAgdGhpcy5jaGlsZCA9IFtdOyAvL25lc3RlZCB0YWdzLCB0ZXh0LCBjZGF0YSwgY29tbWVudHMgaW4gb3JkZXJcbiAgICB0aGlzW1wiOkBcIl0gPSB7fTsgLy9hdHRyaWJ1dGVzIG1hcFxuICB9XG4gIGFkZChrZXksdmFsKXtcbiAgICAvLyB0aGlzLmNoaWxkLnB1c2goIHtuYW1lIDoga2V5LCB2YWw6IHZhbCwgaXNDZGF0YTogaXNDZGF0YSB9KTtcbiAgICBpZihrZXkgPT09IFwiX19wcm90b19fXCIpIGtleSA9IFwiI19fcHJvdG9fX1wiO1xuICAgIHRoaXMuY2hpbGQucHVzaCgge1trZXldOiB2YWwgfSk7XG4gIH1cbiAgYWRkQ2hpbGQobm9kZSkge1xuICAgIGlmKG5vZGUudGFnbmFtZSA9PT0gXCJfX3Byb3RvX19cIikgbm9kZS50YWduYW1lID0gXCIjX19wcm90b19fXCI7XG4gICAgaWYobm9kZVtcIjpAXCJdICYmIE9iamVjdC5rZXlzKG5vZGVbXCI6QFwiXSkubGVuZ3RoID4gMCl7XG4gICAgICB0aGlzLmNoaWxkLnB1c2goIHsgW25vZGUudGFnbmFtZV06IG5vZGUuY2hpbGQsIFtcIjpAXCJdOiBub2RlW1wiOkBcIl0gfSk7XG4gICAgfWVsc2V7XG4gICAgICB0aGlzLmNoaWxkLnB1c2goIHsgW25vZGUudGFnbmFtZV06IG5vZGUuY2hpbGQgfSk7XG4gICAgfVxuICB9O1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFhtbE5vZGU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-xml-parser/src/xmlparser/xmlNode.js\n");

/***/ })

};
;