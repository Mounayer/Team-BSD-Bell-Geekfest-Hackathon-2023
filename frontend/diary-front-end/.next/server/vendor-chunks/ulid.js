/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ulid";
exports.ids = ["vendor-chunks/ulid"];
exports.modules = {

/***/ "(ssr)/./node_modules/ulid/dist/index.umd.js":
/*!*********************************************!*\
  !*** ./node_modules/ulid/dist/index.umd.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function (global, factory) {\n\t true ? factory(exports) :\n\t0;\n}(this, (function (exports) { 'use strict';\n\nfunction createError(message) {\n    var err = new Error(message);\n    err.source = \"ulid\";\n    return err;\n}\n// These values should NEVER change. If\n// they do, we're no longer making ulids!\nvar ENCODING = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"; // Crockford's Base32\nvar ENCODING_LEN = ENCODING.length;\nvar TIME_MAX = Math.pow(2, 48) - 1;\nvar TIME_LEN = 10;\nvar RANDOM_LEN = 16;\nfunction replaceCharAt(str, index, char) {\n    if (index > str.length - 1) {\n        return str;\n    }\n    return str.substr(0, index) + char + str.substr(index + 1);\n}\nfunction incrementBase32(str) {\n    var done = undefined;\n    var index = str.length;\n    var char = void 0;\n    var charIndex = void 0;\n    var maxCharIndex = ENCODING_LEN - 1;\n    while (!done && index-- >= 0) {\n        char = str[index];\n        charIndex = ENCODING.indexOf(char);\n        if (charIndex === -1) {\n            throw createError(\"incorrectly encoded string\");\n        }\n        if (charIndex === maxCharIndex) {\n            str = replaceCharAt(str, index, ENCODING[0]);\n            continue;\n        }\n        done = replaceCharAt(str, index, ENCODING[charIndex + 1]);\n    }\n    if (typeof done === \"string\") {\n        return done;\n    }\n    throw createError(\"cannot increment this string\");\n}\nfunction randomChar(prng) {\n    var rand = Math.floor(prng() * ENCODING_LEN);\n    if (rand === ENCODING_LEN) {\n        rand = ENCODING_LEN - 1;\n    }\n    return ENCODING.charAt(rand);\n}\nfunction encodeTime(now, len) {\n    if (isNaN(now)) {\n        throw new Error(now + \" must be a number\");\n    }\n    if (now > TIME_MAX) {\n        throw createError(\"cannot encode time greater than \" + TIME_MAX);\n    }\n    if (now < 0) {\n        throw createError(\"time must be positive\");\n    }\n    if (Number.isInteger(now) === false) {\n        throw createError(\"time must be an integer\");\n    }\n    var mod = void 0;\n    var str = \"\";\n    for (; len > 0; len--) {\n        mod = now % ENCODING_LEN;\n        str = ENCODING.charAt(mod) + str;\n        now = (now - mod) / ENCODING_LEN;\n    }\n    return str;\n}\nfunction encodeRandom(len, prng) {\n    var str = \"\";\n    for (; len > 0; len--) {\n        str = randomChar(prng) + str;\n    }\n    return str;\n}\nfunction decodeTime(id) {\n    if (id.length !== TIME_LEN + RANDOM_LEN) {\n        throw createError(\"malformed ulid\");\n    }\n    var time = id.substr(0, TIME_LEN).split(\"\").reverse().reduce(function (carry, char, index) {\n        var encodingIndex = ENCODING.indexOf(char);\n        if (encodingIndex === -1) {\n            throw createError(\"invalid character found: \" + char);\n        }\n        return carry += encodingIndex * Math.pow(ENCODING_LEN, index);\n    }, 0);\n    if (time > TIME_MAX) {\n        throw createError(\"malformed ulid, timestamp too large\");\n    }\n    return time;\n}\nfunction detectPrng() {\n    var allowInsecure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var root = arguments[1];\n\n    if (!root) {\n        root = typeof window !== \"undefined\" ? window : null;\n    }\n    var browserCrypto = root && (root.crypto || root.msCrypto);\n    if (browserCrypto) {\n        return function () {\n            var buffer = new Uint8Array(1);\n            browserCrypto.getRandomValues(buffer);\n            return buffer[0] / 0xff;\n        };\n    } else {\n        try {\n            var nodeCrypto = __webpack_require__(/*! crypto */ \"crypto\");\n            return function () {\n                return nodeCrypto.randomBytes(1).readUInt8() / 0xff;\n            };\n        } catch (e) {}\n    }\n    if (allowInsecure) {\n        try {\n            console.error(\"secure crypto unusable, falling back to insecure Math.random()!\");\n        } catch (e) {}\n        return function () {\n            return Math.random();\n        };\n    }\n    throw createError(\"secure crypto unusable, insecure Math.random not allowed\");\n}\nfunction factory(currPrng) {\n    if (!currPrng) {\n        currPrng = detectPrng();\n    }\n    return function ulid(seedTime) {\n        if (isNaN(seedTime)) {\n            seedTime = Date.now();\n        }\n        return encodeTime(seedTime, TIME_LEN) + encodeRandom(RANDOM_LEN, currPrng);\n    };\n}\nfunction monotonicFactory(currPrng) {\n    if (!currPrng) {\n        currPrng = detectPrng();\n    }\n    var lastTime = 0;\n    var lastRandom = void 0;\n    return function ulid(seedTime) {\n        if (isNaN(seedTime)) {\n            seedTime = Date.now();\n        }\n        if (seedTime <= lastTime) {\n            var incrementedRandom = lastRandom = incrementBase32(lastRandom);\n            return encodeTime(lastTime, TIME_LEN) + incrementedRandom;\n        }\n        lastTime = seedTime;\n        var newRandom = lastRandom = encodeRandom(RANDOM_LEN, currPrng);\n        return encodeTime(seedTime, TIME_LEN) + newRandom;\n    };\n}\nvar ulid = factory();\n\nexports.replaceCharAt = replaceCharAt;\nexports.incrementBase32 = incrementBase32;\nexports.randomChar = randomChar;\nexports.encodeTime = encodeTime;\nexports.encodeRandom = encodeRandom;\nexports.decodeTime = decodeTime;\nexports.detectPrng = detectPrng;\nexports.factory = factory;\nexports.monotonicFactory = monotonicFactory;\nexports.ulid = ulid;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdWxpZC9kaXN0L2luZGV4LnVtZC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLENBQUMsS0FBNEQ7QUFDN0QsQ0FBQyxDQUM2QjtBQUM5QixDQUFDLDZCQUE2Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw2QkFBNkIsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLGFBQWE7O0FBRTVELENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kaWFyeS1mcm9udC1lbmQvLi9ub2RlX21vZHVsZXMvdWxpZC9kaXN0L2luZGV4LnVtZC5qcz9jZmVmIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5VTElEID0ge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIGVyci5zb3VyY2UgPSBcInVsaWRcIjtcbiAgICByZXR1cm4gZXJyO1xufVxuLy8gVGhlc2UgdmFsdWVzIHNob3VsZCBORVZFUiBjaGFuZ2UuIElmXG4vLyB0aGV5IGRvLCB3ZSdyZSBubyBsb25nZXIgbWFraW5nIHVsaWRzIVxudmFyIEVOQ09ESU5HID0gXCIwMTIzNDU2Nzg5QUJDREVGR0hKS01OUFFSU1RWV1hZWlwiOyAvLyBDcm9ja2ZvcmQncyBCYXNlMzJcbnZhciBFTkNPRElOR19MRU4gPSBFTkNPRElORy5sZW5ndGg7XG52YXIgVElNRV9NQVggPSBNYXRoLnBvdygyLCA0OCkgLSAxO1xudmFyIFRJTUVfTEVOID0gMTA7XG52YXIgUkFORE9NX0xFTiA9IDE2O1xuZnVuY3Rpb24gcmVwbGFjZUNoYXJBdChzdHIsIGluZGV4LCBjaGFyKSB7XG4gICAgaWYgKGluZGV4ID4gc3RyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgaW5kZXgpICsgY2hhciArIHN0ci5zdWJzdHIoaW5kZXggKyAxKTtcbn1cbmZ1bmN0aW9uIGluY3JlbWVudEJhc2UzMihzdHIpIHtcbiAgICB2YXIgZG9uZSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgaW5kZXggPSBzdHIubGVuZ3RoO1xuICAgIHZhciBjaGFyID0gdm9pZCAwO1xuICAgIHZhciBjaGFySW5kZXggPSB2b2lkIDA7XG4gICAgdmFyIG1heENoYXJJbmRleCA9IEVOQ09ESU5HX0xFTiAtIDE7XG4gICAgd2hpbGUgKCFkb25lICYmIGluZGV4LS0gPj0gMCkge1xuICAgICAgICBjaGFyID0gc3RyW2luZGV4XTtcbiAgICAgICAgY2hhckluZGV4ID0gRU5DT0RJTkcuaW5kZXhPZihjaGFyKTtcbiAgICAgICAgaWYgKGNoYXJJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUVycm9yKFwiaW5jb3JyZWN0bHkgZW5jb2RlZCBzdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXJJbmRleCA9PT0gbWF4Q2hhckluZGV4KSB7XG4gICAgICAgICAgICBzdHIgPSByZXBsYWNlQ2hhckF0KHN0ciwgaW5kZXgsIEVOQ09ESU5HWzBdKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGRvbmUgPSByZXBsYWNlQ2hhckF0KHN0ciwgaW5kZXgsIEVOQ09ESU5HW2NoYXJJbmRleCArIDFdKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkb25lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBkb25lO1xuICAgIH1cbiAgICB0aHJvdyBjcmVhdGVFcnJvcihcImNhbm5vdCBpbmNyZW1lbnQgdGhpcyBzdHJpbmdcIik7XG59XG5mdW5jdGlvbiByYW5kb21DaGFyKHBybmcpIHtcbiAgICB2YXIgcmFuZCA9IE1hdGguZmxvb3IocHJuZygpICogRU5DT0RJTkdfTEVOKTtcbiAgICBpZiAocmFuZCA9PT0gRU5DT0RJTkdfTEVOKSB7XG4gICAgICAgIHJhbmQgPSBFTkNPRElOR19MRU4gLSAxO1xuICAgIH1cbiAgICByZXR1cm4gRU5DT0RJTkcuY2hhckF0KHJhbmQpO1xufVxuZnVuY3Rpb24gZW5jb2RlVGltZShub3csIGxlbikge1xuICAgIGlmIChpc05hTihub3cpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihub3cgKyBcIiBtdXN0IGJlIGEgbnVtYmVyXCIpO1xuICAgIH1cbiAgICBpZiAobm93ID4gVElNRV9NQVgpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoXCJjYW5ub3QgZW5jb2RlIHRpbWUgZ3JlYXRlciB0aGFuIFwiICsgVElNRV9NQVgpO1xuICAgIH1cbiAgICBpZiAobm93IDwgMCkge1xuICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihcInRpbWUgbXVzdCBiZSBwb3NpdGl2ZVwiKTtcbiAgICB9XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIobm93KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoXCJ0aW1lIG11c3QgYmUgYW4gaW50ZWdlclwiKTtcbiAgICB9XG4gICAgdmFyIG1vZCA9IHZvaWQgMDtcbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICBmb3IgKDsgbGVuID4gMDsgbGVuLS0pIHtcbiAgICAgICAgbW9kID0gbm93ICUgRU5DT0RJTkdfTEVOO1xuICAgICAgICBzdHIgPSBFTkNPRElORy5jaGFyQXQobW9kKSArIHN0cjtcbiAgICAgICAgbm93ID0gKG5vdyAtIG1vZCkgLyBFTkNPRElOR19MRU47XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBlbmNvZGVSYW5kb20obGVuLCBwcm5nKSB7XG4gICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgZm9yICg7IGxlbiA+IDA7IGxlbi0tKSB7XG4gICAgICAgIHN0ciA9IHJhbmRvbUNoYXIocHJuZykgKyBzdHI7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBkZWNvZGVUaW1lKGlkKSB7XG4gICAgaWYgKGlkLmxlbmd0aCAhPT0gVElNRV9MRU4gKyBSQU5ET01fTEVOKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKFwibWFsZm9ybWVkIHVsaWRcIik7XG4gICAgfVxuICAgIHZhciB0aW1lID0gaWQuc3Vic3RyKDAsIFRJTUVfTEVOKS5zcGxpdChcIlwiKS5yZXZlcnNlKCkucmVkdWNlKGZ1bmN0aW9uIChjYXJyeSwgY2hhciwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGVuY29kaW5nSW5kZXggPSBFTkNPRElORy5pbmRleE9mKGNoYXIpO1xuICAgICAgICBpZiAoZW5jb2RpbmdJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUVycm9yKFwiaW52YWxpZCBjaGFyYWN0ZXIgZm91bmQ6IFwiICsgY2hhcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhcnJ5ICs9IGVuY29kaW5nSW5kZXggKiBNYXRoLnBvdyhFTkNPRElOR19MRU4sIGluZGV4KTtcbiAgICB9LCAwKTtcbiAgICBpZiAodGltZSA+IFRJTUVfTUFYKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKFwibWFsZm9ybWVkIHVsaWQsIHRpbWVzdGFtcCB0b28gbGFyZ2VcIik7XG4gICAgfVxuICAgIHJldHVybiB0aW1lO1xufVxuZnVuY3Rpb24gZGV0ZWN0UHJuZygpIHtcbiAgICB2YXIgYWxsb3dJbnNlY3VyZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgdmFyIHJvb3QgPSBhcmd1bWVudHNbMV07XG5cbiAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgcm9vdCA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiBudWxsO1xuICAgIH1cbiAgICB2YXIgYnJvd3NlckNyeXB0byA9IHJvb3QgJiYgKHJvb3QuY3J5cHRvIHx8IHJvb3QubXNDcnlwdG8pO1xuICAgIGlmIChicm93c2VyQ3J5cHRvKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgICAgICAgICBicm93c2VyQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyhidWZmZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlclswXSAvIDB4ZmY7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBub2RlQ3J5cHRvID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVDcnlwdG8ucmFuZG9tQnl0ZXMoMSkucmVhZFVJbnQ4KCkgLyAweGZmO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gICAgaWYgKGFsbG93SW5zZWN1cmUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJzZWN1cmUgY3J5cHRvIHVudXNhYmxlLCBmYWxsaW5nIGJhY2sgdG8gaW5zZWN1cmUgTWF0aC5yYW5kb20oKSFcIik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgY3JlYXRlRXJyb3IoXCJzZWN1cmUgY3J5cHRvIHVudXNhYmxlLCBpbnNlY3VyZSBNYXRoLnJhbmRvbSBub3QgYWxsb3dlZFwiKTtcbn1cbmZ1bmN0aW9uIGZhY3RvcnkoY3VyclBybmcpIHtcbiAgICBpZiAoIWN1cnJQcm5nKSB7XG4gICAgICAgIGN1cnJQcm5nID0gZGV0ZWN0UHJuZygpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdWxpZChzZWVkVGltZSkge1xuICAgICAgICBpZiAoaXNOYU4oc2VlZFRpbWUpKSB7XG4gICAgICAgICAgICBzZWVkVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY29kZVRpbWUoc2VlZFRpbWUsIFRJTUVfTEVOKSArIGVuY29kZVJhbmRvbShSQU5ET01fTEVOLCBjdXJyUHJuZyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1vbm90b25pY0ZhY3RvcnkoY3VyclBybmcpIHtcbiAgICBpZiAoIWN1cnJQcm5nKSB7XG4gICAgICAgIGN1cnJQcm5nID0gZGV0ZWN0UHJuZygpO1xuICAgIH1cbiAgICB2YXIgbGFzdFRpbWUgPSAwO1xuICAgIHZhciBsYXN0UmFuZG9tID0gdm9pZCAwO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bGlkKHNlZWRUaW1lKSB7XG4gICAgICAgIGlmIChpc05hTihzZWVkVGltZSkpIHtcbiAgICAgICAgICAgIHNlZWRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VlZFRpbWUgPD0gbGFzdFRpbWUpIHtcbiAgICAgICAgICAgIHZhciBpbmNyZW1lbnRlZFJhbmRvbSA9IGxhc3RSYW5kb20gPSBpbmNyZW1lbnRCYXNlMzIobGFzdFJhbmRvbSk7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlVGltZShsYXN0VGltZSwgVElNRV9MRU4pICsgaW5jcmVtZW50ZWRSYW5kb207XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFRpbWUgPSBzZWVkVGltZTtcbiAgICAgICAgdmFyIG5ld1JhbmRvbSA9IGxhc3RSYW5kb20gPSBlbmNvZGVSYW5kb20oUkFORE9NX0xFTiwgY3VyclBybmcpO1xuICAgICAgICByZXR1cm4gZW5jb2RlVGltZShzZWVkVGltZSwgVElNRV9MRU4pICsgbmV3UmFuZG9tO1xuICAgIH07XG59XG52YXIgdWxpZCA9IGZhY3RvcnkoKTtcblxuZXhwb3J0cy5yZXBsYWNlQ2hhckF0ID0gcmVwbGFjZUNoYXJBdDtcbmV4cG9ydHMuaW5jcmVtZW50QmFzZTMyID0gaW5jcmVtZW50QmFzZTMyO1xuZXhwb3J0cy5yYW5kb21DaGFyID0gcmFuZG9tQ2hhcjtcbmV4cG9ydHMuZW5jb2RlVGltZSA9IGVuY29kZVRpbWU7XG5leHBvcnRzLmVuY29kZVJhbmRvbSA9IGVuY29kZVJhbmRvbTtcbmV4cG9ydHMuZGVjb2RlVGltZSA9IGRlY29kZVRpbWU7XG5leHBvcnRzLmRldGVjdFBybmcgPSBkZXRlY3RQcm5nO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbmV4cG9ydHMubW9ub3RvbmljRmFjdG9yeSA9IG1vbm90b25pY0ZhY3Rvcnk7XG5leHBvcnRzLnVsaWQgPSB1bGlkO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ulid/dist/index.umd.js\n");

/***/ })

};
;